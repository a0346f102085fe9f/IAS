<!DOCTYPE html>
<!-- IAS -->
<!-- JUMP TO BOTTOM OF THE FILE TO FIND THE ENTRY POINT -->
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>IAS</title><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="tags.css"></head><body><nav><div class="nav_topbar"><div class="nav_buttons"></div><input type="text" class="nav_search"></div><div class="nav_dropdown"></div></nav><div class="status_area"></div><content><noscript><div class="box"><p>Can't work without JavaScript, unfortunately.</p></div></noscript></content>
<script src="lunr.js" type="text/javascript"></script>
<script>
"use strict";

// Source object
// Stores the source code of the API Servers / components
// bootloader.init() will initialize them:
// - ias.core -> window.core
// - ias.story -> window.story
// - ias.locale -> window.locale
// - etc...
//
// Only after initialization can you use them!
//
var ias = {}
</script>

<script>
"use strict";

ias.locale = function() {
	//
	// IAS localization strings
	//
	// ==============================================================================
	
	this.date_format = undefined
	this.date_options = {year: "numeric", month: "long", day: "numeric", hour: "numeric", minute: "numeric"}

	this.note_missing = "A note with this title does not yet exist. Use the Create button to create it!"
	this.new_note_title = "Note "

	this.search_placeholder = "Search..."

	this.saving_error = "Unable to save!"
	this.saving_ok = "Saved."

	this.network_error = "Networking: network error"
	this.server_error = "Networking: server error"
	this.error_code = "Error code: "
	this.address = "Address: "

	this.parser_missing = "This note uses an unknown parser: "

	// ==============================================================================
}

ias.core = function() {
	//
	// IAS core
	//
	// ==============================================================================
	
	// The code to load the notes, save the notes, search the notes, etc...
	// 
	// Each note is an object that features a set of fields;
	// Most importantly:
	// - Title
	// - Text
	// - Created
	// - Modified
	//
	// There's also a set of secondary, optional fields:
	// - Archived Note Flag [Hides the note from the usual search]
	// - System Note Flag 	[Hides the note from the usual search]
	// - List of tags 		[Just an array of tags]
	// - Parser 			[Either "Markdown", "Text", "App" or a "Process"]
	//
	// Really you can add any field you need, but these are reserved
	//
	
	//
	// List of APIs:
	// - note_exists(title)
	// - create_note(title)
	// - delete_note(title)
	// - rename_note(title, new_title)
	// - get_note_reference(title)
	// - get_note_text(title)
	// - set_note_text(title, text)
	// - for_each_note(callback)
	// - get_oldest_titles(number)
	// - get_recent_titles(number)
	// - get_notes_with_field(field, value)
	// - archive_note(title)
	// - unarchive_note(title)
	// - export_note(title, id)
	// - cold_storage_snapshot()
	// - cold_storage_restore()
	// - float_to_bottom(title)					INTERNAL
	// - update_title_hashmap()					INTERNAL
	// - fire_alert()							INTERNAL
	//
	
	// Async Function Constructor
	// A bit of a hidden feature, but seems to have been supported for a long time
	window.AsyncFunction = Object.getPrototypeOf(async function(){}).constructor
	
	// Note storage
	// WARNING: reveal_pointers() needs to be called again if one of the variables is ever reassigned!
	//
	// notes	[id => note_object] 	always sorted note.modified ASCENDING
	// titles	{note_title => id}		not sorted
	var notes = []
	var titles = {}
	

	// Check whether a note by this title exists
	this.note_exists = function(title) {
		return (title in titles)
	}

	// Create a new note
	this.create_note = function(title) {
		var note = {}
		
		// Check if a note by this title already exists
		if (titles[title] != undefined) {
			log("Tried to create a note ["+title+"] but it already exists!")
			return null
		}
		
		note.title 		= title
		note.text 		= ""
		note.created 	= Date.now()
		note.modified 	= Date.now()
		note.parser 	= "Markdown"

		var id = notes.push(note) - 1
		titles[title] = id

		this.fire_alert("note_created", title)
		
		return note
	}

	// Delete the note
	// Will leave holes in the notes array, but that's okay
	// It will be flattened upon saving
	this.delete_note = function(title) {
		var id = titles[title]
		
		delete titles[title]
		delete notes[id]

		this.fire_alert("note_deleted", title)
	}

	// Rename the note
	// Will leave holes in the note array
	this.rename_note = function(title, new_title) {
		var id = titles[title]
		var note = notes[id]

		delete titles[title]

		// Punch holes only if necessary
		if (id < notes.length - 1) {
			delete notes[id]

			id = notes.push(note) - 1
		}

		note.title = new_title
		titles[new_title] = id
		note.modified = Date.now()

		this.fire_alert("note_renamed", title)
	}

	// Get the total note count
	// Doesn't count holes
	this.get_note_count = function() {
		var count = 0

		for (var title in titles) {
			count++
		}

		return count
	}

	// Fetch a reference to the note
	// * Low level function!
	// * Fields may not be populated
	// * DO NOT, NEVER write any fields directly
	// [Potential place to implement a one-deep cache later]
	this.get_note_reference = function(title) {
		var id = titles[title]
		var note = notes[id]

		return note
	}
	
	// Fetch the note text only
	this.get_note_text = function(title) {
		var note = this.get_note_reference(title)

		return note.text
	}

	// Set the note text only
	this.set_note_text = function(title, text) {
		var note = this.get_note_reference(title)

		note.text = text
		note.modified = Date.now()

		this.float_to_bottom(title)
		this.fire_alert("note_altered", title)
	}
	
	// Iterate over each note and call the callback
	// * Supports async functions
	this.for_each_note = function(callback) {
		for (var note of notes) {
			if (note != undefined) callback(note)
		}
	}

	// Returns an array of titles that match the pattern
	// * Pattern uses space as a separator
	// * Case-insensitive
	this.find_titles = function(pattern, ignore_archived = true) {
		var note_list = []
		var bits = pattern.toLowerCase().split(" ")

		for (var title in titles) {
			var lowercase_title = title.toLowerCase()
			var nope = false

			for (var bit of bits) {
				if (lowercase_title.includes(bit) === false) {
					nope = true
					break
				}
			}

			if (nope) {
				continue
			} else {
				if (ignore_archived) {
					var note = this.get_note_reference(title)

					if (note.archived) {
						continue
					}
				}

				note_list.push(title)
			}
		}

		return note_list
	}

	// Returns an array no longer than [number]
	this.get_oldest_titles = function(number) {
		var note_list = []
		var len = notes.length

		for (var j = 0, i = 0; (i < len) && (j < number);) {
			if (i in notes) { // Skip over holes
				note_list.push(notes[i].title)
				j++
			}
			i++
		}

		return note_list
	}

	// Returns an array no longer than [number]
	this.get_recent_titles = function(number) {
		var note_list = []

		for (var j = 0, i = notes.length - 1; (i >= 0) && (j < number);) {
			if (i in notes) { // Skip over holes
				note_list.push(notes[i].title)
				j++
			}
			i--
		}

		return note_list
	}

	// Get notes that contain a certain [field] with certain [value]
	// If [value] is not specified, will count any note that has the field
	this.get_notes_with_field = function(field, value = null) {
		var note_list = []
		var len = notes.length

		for (var i = 0; i < len; i++) {
			if (i in notes) {
				if (field in notes[i]) {
					if (value === null) {
						note_list.push(notes[i].title)
					} else if (value === notes[i][field]) {
						note_list.push(notes[i].title)
					}
				}
			}
		}

		return note_list
	}

	this.archive_note = function(title) {
		var note = this.get_note_reference(title)

		if (!note.archived) {
			note.archived = true
			this.fire_alert("note_altered", title)
		}
	}

	this.unarchive_note = function(title) {
		var note = this.get_note_reference(title)

		if (note.archived) {
			delete note["archived"]
			this.fire_alert("note_altered", title)
		}
	}

	// Export a note by a title or by id
	this.export_note = function(title, id = null) {
		if (id === null) id = titles[title]

		var note_json = ""
		var note = notes[id]

		for (var field in note) {
			var value = note[field]
			var type = typeof(value)
			var wrap = ""
			
			if (type === "string") {
				wrap = "`"

				// Replace certain symbols that interfere with JavaScript's multiline strings
				// [ \ ] 	-> [ \\ ]
				// [ ` ] 	-> [ \` ]
				// [ ${ ] 	-> [ \${ ]
				// Also break up any script closing tags
				value = value.
				replaceAll("\\", "\\\\").
				replaceAll("`", "\\`").
				replaceAll("${", "\\${").
				replaceAll("</"+"script>", "</${'script'}>")
			}
			
			if (note_json.length != 0) note_json += ",\n"
			
			note_json += field + ":" + (wrap + value + wrap)
		}

		return "{\n" + note_json + "\n}"
	}
	
	// Generate a string of JS code that will replicate the note storage memory structure
	// Holes are removed
	this.cold_storage_snapshot = function() {
		var result = ""
		
		for (var id = 0; id < notes.length; id++) {
			if (id in notes === false) continue

			var note_json = this.export_note(null, id)
			
			if (result.length != 0) result += ",\n"
			result += note_json
		}
		
		return "[" + result + "]"
	}
	
	// Restore from an already evaluated snapshot
	this.cold_storage_restore = function() {
		notes = ias_cold_storage
		this.update_title_hashmap()
	}

	// Float the note to bottom
	// Will leave holes in the note array
	// Used as a mechanism to fight excessive truncation
	this.float_to_bottom = function(title) {
		var id = titles[title]
		
		// Return if note is already at the bottom
		if (id === notes.length - 1) {
			return
		}

		var note = notes[id]

		delete notes[id]

		var new_id = notes.push(note) - 1
		titles[title] = new_id
	}
	
	// Needs to be called after restoring from snapshot
	this.update_title_hashmap = function() {
		for (var id = notes.length - 1; id >= 0; id--) {
			var title = notes[id].title
			titles[title] = id
		}
	}

	// Fire this to alert things that note storage was modified
	//
	// Currently supported alerts
	// - note_created
	// - note_altered
	// - note_renamed
	// - note_deleted
	//
	this.fire_alert = function(alert, cause) {
		story.alert(alert, cause)
		story.alert_all_notes(alert, cause)

		search.alert(alert, cause)
		navbar.alert(alert, cause)
		dropdown.alert(alert, cause)
	}

	// Reveal or update debug pointers
	this.reveal_pointers = function() {
		this.notes = notes
		this.titles = titles
	}
	// ==============================================================================
}

ias.bootloader = function() {
	//
	// IAS bootloader
	//
	// ==============================================================================
	this.init = function() {
		window.onerror = this.handle_error
		window.onunhandledrejection = this.handle_error
		window.log = console.log

		// Can be any object
		var root = window
		
		root.bootloader = this

		// Initialize an instance of EVERYTHING that was added into window.ias
		for (var component in ias) {
			root[component] = new window.ias[component]
		}

			
		root.core.cold_storage_restore()

		// Delete the original cold storage reference
		// Now referenced by core.notes
		delete window.ias_cold_storage

		// Initial app start
		navbar.init()
		dropdown.init()

		story.open_note("Welcome")
		story.open_note("Search")

		// Check whether the URL is clean of anchors
		// If yes, open the default note
		// Otherwise, open the linked note
		if (location.hash === "") {
			//story.open_note( default_note )
		} else {
			story.open_note( decodeURI(location.hash.slice(1)) )
		}

	}

	// JavaScript error handler
	this.handle_error = function(description, url, line, column, error) {
		if ("crash_count" in window === false) {
			window.crash_count = 0
		}

		crash_count++

		// Special handling for errors that occured within Async functions
		// Seems to be Firefox-specific to consider async errors promise rejections
		// Chromium considers async errors normal errors
		if (typeof(description) === "object") {
			if ("reason" in description) {
				var reason = description.reason

				description = reason.message
				url = reason.fileName
				line = reason.lineNumber
				column = reason.columnNumber
				error = {}
				error.stack = reason.stack
			}
		}

		var stack_trace = ""

		if (!error) {
			stack_trace = " --- NO ERROR INFO AVAILABLE --- "
		} else if ("stack" in error === false) {
			stack_trace = " --- NO STACK TRACE AVAILABLE --- "
		} else {
			// Firefox specific prettyfication
			// Doesn't break chromium
			stack_trace = error.stack.replace(/\n@/g, "\nanonymous@").replace(/@/g, "   @   ").replace(/\n/g, "\n\t")
		}

		var message = ""
		+ " === Crash report #" + crash_count + " === \n"
		+ "A crash has occurred in:\n"
		+ "<"+url+">:"+line+" --- " + description + "\n\n"
		+ "Stack trace: \n	" + stack_trace + "\n\n"
		+ "A restart is advised.\n\n"
		
		alert(message)
	}

	this.hash = "aaaaad0b03231ca27d61173c145a3b3c18b977b4742de578710fab0478251ae0"
	// ==============================================================================
}

ias.utils = function() {
	//
	// IAS misc utils
	//
	// ==============================================================================

	// List of APIs:
	// - q_id(...)
	// - q_sel(...)
	// - add(tagname, parent, id)
	// - adjacent_add(tagname, target, where, id)
	// - dom_reverse_traverse(element, target_tag)
	// - strectes_beyond_viewport(element)
	// - error(text)
	// - success(text)
	// - show_status(text)
	// - hide_status()
	// - format_time(timestamp)
	// - get_new_title()
	// - apply_css(css)
	// - display_title(title)
	// - display_tags(tags)
	// - display_tag(tag)
	//

	// Alias
	var utils = this

	// Query ID alias
	window.q_id = document.getElementById.bind(document)

	// Query selector alias
	window.q_sel = document.querySelector.bind(document)
	
	// Make an element helper
	window.add = function(tagname, parent = document.body, id = null) {
		var element = document.createElement(tagname)
		
		if (id != null) element.id = name
		parent.appendChild(element)
		
		return element
	}

	// Make an adjacent element helper
	// Where can be:
	// - beforebegin
	// - afterbegin
	// - beforeend
	// - afterned
	window.adjacent_add = function(tagname, target, where = "beforebegin", id = null) {
		var element = document.createElement(tagname)
		
		if (id != null) element.id = name
		target.insertAdjacentElement(where, element)
		
		return element
	}

	// Walk up the DOM tree until a <TARGET_TAG> element is found
	// Note: target tag must be in ALL CAPS
	window.dom_reverse_traverse = function(element, target_tag) {
		// Reached the absolute top
		if ("parentElement" in element === false) {
			return false
		}

		if (element.parentElement.tagName === target_tag) {
			return element
		} else {
			return dom_reverse_traverse(element.parentElement, target_tag)
		}
	}

	// Check if a part of the element, or the entire element, stretches beyond the viewport
	window.stretches_beyond_viewport = function(element) {
		return (window.innerHeight + window.scrollY < element.offsetTop + element.scrollHeight)
	}


	window.error = function(text) {
		show_status(text)

		statusbox.classList.add("error")
	}

	window.success = function(text) {
		show_status(text)

		statusbox.classList.add("success")
		setTimeout(hide_status, 5000)
	}

	// Display a status box in the status area
	window.show_status = function(text) {
		if ("statusbox" in window === false) {
			window.statusbox = add("div", q_sel("body .status_area"))
			statusbox.classList.add("status_box")
		}
		
		statusbox.classList.remove("success")
		statusbox.classList.remove("error")
		statusbox.classList.remove("hide")
		statusbox.innerHTML = text

		statusbox.onclick = hide_status
	}

	window.hide_status = function() {
		statusbox.classList.add("hide")
	}

	// https://stackoverflow.com/a/34278578
	utils.insert_at_cursor = function(text, element) {
		var start = element.selectionStart
		var end = element.selectionEnd
		
		element.setRangeText(text, start, end, 'end');
	}

	// Parse a YYYYMMDDHHMMSSmmm TiddlyWiki-style timestamp into a millisecond Unix timestamp
	utils.parse_note_timestamp = function(note_timestamp) {
		var str = note_timestamp.toString()

		var year 	= parseInt( str.slice( 0,  4) )
		var month 	= parseInt( str.slice( 4,  6) ) - 1
		var day 	= parseInt( str.slice( 6,  8) )
		var hour 	= parseInt( str.slice( 8, 10) )
		var minute 	= parseInt( str.slice(10, 12) )
		var second 	= parseInt( str.slice(12, 14) )
		var ms 		= parseInt( str.slice(14, 17) )

		return Date.UTC(year, month, day, hour, minute, second, ms)
	}

	// Convert Unix millisecond timestamp into a YYYYMMDDHHMMSSmmm format
	utils.make_note_timestamp = function(timestamp) {
		var date = new Date(timestamp)

		var year 	= ( date.getUTCFullYear() 		).toString()
		var month 	= ( date.getUTCMonth() + 1		).toString().padStart(2, "0")
		var day 	= ( date.getUTCDate()			).toString().padStart(2, "0")
		var hour 	= ( date.getUTCHours() 			).toString().padStart(2, "0")
		var minute 	= ( date.getUTCMinutes() 		).toString().padStart(2, "0")
		var second 	= ( date.getUTCSeconds() 		).toString().padStart(2, "0")
		var ms 		= ( date.getUTCMilliseconds()	).toString()

		return year+month+day+hour+minute+second+ms
	}

	// Converts supplied timestamp to local format
	utils.format_time = function(timestamp) {
		return new Date(timestamp).toLocaleString(locale.date_format, locale.date_options)
	}

	// Return a title for a new note
	utils.get_new_title = function() {
		return locale.new_note_title + (core.get_note_count() + 1)
	}

	// Switch to a new CSS
	// Not additive, replaces CSS fully
	utils.apply_css = function(css) {
		var style = q_sel("style")

		if (style === null) {
			style = add("style", document.head)
		}

		style.innerText = css
	}

	// Format a note title into a clickable link
	utils.display_title = function(title, open_after = "") {
		return "<a class=\"internal auto\" href=\"#"+title+"\" onclick=\"story.open_note('"+title.replace(/'/g, "\\'")+"', '"+open_after+"'); return false;\">"+title+"</a>"
	}

	// Format an array of tags into a set of pillows
	utils.display_tags = function(tags) {
		var html = "<span class=\"tag_list\">"
		var len = tags.length

		for (var i = 0; i < len; i++)
			html += utils.display_tag(tags[i])

		return html + "</span>"
	}

	// Format a single tag into a <span> pillow
	utils.display_tag = function(tag) {
		// Ignore empty tags
		if (tag === "")
			return ""

		// Regular expression to detect symbols not safe to place inside an HTML attribute
		var rxp_unsafe = /[^A-Za-zА-Яа-я0-9ёЁ-]/g
		var safe_tag = tag.replace(rxp_unsafe, "")

		return "<span class=\"tag tg-" + safe_tag + "\">" + tag + "</span>"
	}

	// DIY map with fixed number of slots and growing insertion cutoff
	utils.sortedmap = function(slots) {
		var sm = {}

		var cutoff = 0
		var map = {}
		var len = 0

		// Insert a value - object pair
		sm.insert = function(value, object) {
			if (value > cutoff) {

				if (len < slots) {
					len++
				} else {
					var min = cutoff 

					for (var i_value in map)
						if (i_value < min) min = i_value

					delete map[min]
				}

				map[value] = object
				cutoff = value
			}
		}

		// Print out the map
		sm.log = function() {
			log(map)
		}

		sm.map = map

		return sm
	}
	// ==============================================================================
}

ias.story = function() {
	//
	// IAS GUI; story
	//
	// ==============================================================================

	// Shortcut
	var story = this

	story.entries = {}

	// Shortcut 2
	var entries = story.entries

	// Alert the story that a note changed
	this.alert = function(alert, cause) {
		if (cause in entries === false) {
			return
		}

		var note = entries[cause]

		// On alterations, reload the note
		if (alert === "note_altered") {
			note.reload()
		}

		// On renames, remove the stale title and re-add the note under a new title
		if (alert === "note_renamed") {
			delete entries[cause]
			entries[note.info.title] = note
			note.set_title(note.info.title)
		}

		// On deletions, close the note
		if (alert === "note_deleted") {
			note.close()
		}
	}

	// Alert all notes within the story
	// If entries[cause] exists, run the edited/renamed/deleted checks
	// Then, for every open note, call a function note[alert]() if available
	this.alert_all_notes = function(alert, cause) {
		for (var title in entries) {
			var note = entries[title]

			if (alert in note.alerts) {
				note.alerts[alert](cause)
			}
		}
	}

	// Create a brand new note (And start editing it)
	this.create_new_note = function() {
		var title = utils.get_new_title()
		var note = story.new_empty_note()

		note.info = core.create_note(title)
		note.info.parser = "Markdown"
		note.reload()
		note.edit()
	}

	// Create a temporary note not backed by the note storage
	this.create_temporary_note = function(after = null) {
		var note = story.new_empty_note(after)

		note.toolbar.display_temporary_toolbar()
		note.set_title("<i>Temporary note</i>")
		note.set_date(utils.format_time( Date.now() ))

		return note
	}

	// A new empty note within the story
	// Completely empty, but with all the APIs ready to operate
	this.new_empty_note = function(after = null) {
		var note = {}

		note.dom = {}
		note.dom.box = document.createElement("div")
		note.dom.box.classList.add("box")

		// If no "after" specified, simply insert the note as a new child in the <content>
		// Otherwise perform adjacent insertion to the target element
		if (after === null) {
			var story_river = q_sel("body content")
			story_river.appendChild(note.dom.box)
		} else {
			if (after in entries) {
				var previous_note = entries[after]
				previous_note.dom.box.insertAdjacentElement("afterend", note.dom.box)
			} else {
				log("Tried to insert a note after ["+after+"] but was unable to find it within the story!")
				var story_river = q_sel("body content")
				story_river.appendChild(note.dom.box)
			}
		}
		
		// Install the APIs and the HTML structure
		story.define_note(note)

		return note
	}

	// Open a note within the story river
	this.open_note = function(title, after = null) {
		// We do not respect notes with empty title
		if (title === "") {
			log("Can't open a note that has no title.")
			return
		}

		// Check whether the note is already open
		// If so, scroll to it and make it blink
		if (title in entries === true) {
			var note = entries[title]
			
			note.scroll_to()
			note.blink()

			return note
		}

		// Check whether the note exists
		// If no, suggest to create it
		if (core.note_exists(title) === false) {
			story.suggest_note(title)
			return
		}



		// Obtain a direct reference to the note
		var info = core.get_note_reference(title)

		// If note is to be executed as a process, we shouldn't create any UIs for it
		// Just run it async and exit
		if (info.parser === "Process") {
			var code = core.get_note_text(title)
			var run = new AsyncFunction(code)
			run()

			return
		}
		

		// Otherwise, we need to initialize the UI + logic
		var note = story.new_empty_note(after)

		note.info = info
		note.reload()

		return note
	}

	// Suggest to create a note
	this.suggest_note = function(title) {
		var note = story.new_empty_note()

		note.toolbar.display_suggestion_toolbar()

		note.set_title(title.italics())
		note.set_date(utils.format_time( Date.now() ))
		note.set_body(locale.note_missing)

		note.scroll_to()
	}

	// Note UI creation and some basic APIs
	// Requires object to have a content box
	//
	// List of APIs:
	// - set_title(text)
	// - set_date(text)
	// - set_body(text)
	// - scroll_to()
	// - blink()
	// - body.q_sel(selector)
	// - editor.disable_wrap()
	// - editor.enable_wrap()
	// - toolbar.display_default_toolbar()						TOOLBAR PRESET
	// - toolbar.display_editing_toolbar()						TOOLBAR PRESET
	// - toolbar.display_temporary_toolbar()					TOOLBAR PRESET
	// - toolbar.display_suggestion_toolbar()					TOOLBAR PRESET
	// - toolbar.add_toolbar_button(name, text)
	// - toolbar.add_menu_button(name, text)
	// - toolbar.clear_buttons()
	// - more()											BUTTON HANDLER
	// - edit()											BUTTON HANDLER
	// - close()										BUTTON HANDLER
	// - delete()										BUTTON HANDLER
	// - abort()										BUTTON HANDLER
	// - save()											BUTTON HANDLER
	// - create()										BUTTON HANDLER
	// - archive()										BUTTON HANDLER
	// - unarchive()									BUTTON HANDLER
	// - reload()
	//
	this.define_note = function(note) {
		// STAGE 0: Exports

		// Various top-level stuff
		note.set_title = set_title
		note.set_date = set_date
		note.set_body = set_body
		note.scroll_to = scroll_to
		note.blink = blink
		note.q_sel = q_sel

		// Editor subfolder
		note.editor = {}
		note.editor.disable_wrap = disable_wrap
		note.editor.enable_wrap = enable_wrap

		// Toolbar subfolder
		note.toolbar = {}
		note.toolbar.display_default_toolbar = display_default_toolbar
		note.toolbar.display_editing_toolbar = display_editing_toolbar
		note.toolbar.display_temporary_toolbar = display_temporary_toolbar
		note.toolbar.display_suggestion_toolbar = display_suggestion_toolbar
		note.toolbar.add_toolbar_button = add_toolbar_button
		note.toolbar.add_menu_button = add_menu_button
		note.toolbar.clear_buttons = clear_buttons

		note.reload = reload

		// Alert handlers
		note.alerts = {}

		//
		// STAGE 1: Structure
		//

		// It all starts with a box
		var box = note.dom.box

		// Note consist of the top, the body and the (hidden) editor
		var top 		= add("div", box)
		var body 		= add("div", box)
		var editor		= add("textarea", box)

		// Top
		// -> Header
		//    -> Title
		//    -> Tools
		// -> Date
		var header 		= add("div", top)
		var title 		= add("div", header)
		var tools 		= add("div", header)
		var date 		= add("div", top)

		// Div to store toolbar buttons
		var buttons 	= add("div", tools)

		// More menu
		var menu_root 	= add("div", tools)
		var menu 		= add("div", menu_root)

		// Set up CSS classes
		header.classList.add("note_header")
		editor.classList.add("note_editor")
		title.classList.add("note_title")
		tools.classList.add("note_tools")
		date.classList.add("note_date")
		body.classList.add("note_body")

		menu_root.classList.add("dropdown_root")
		menu.classList.add("dropdown", "hide")

		// Parser selector
		var parser_selector = add("select", box)

		function add_parser(name, value) { 
			var option = add("option", parser_selector) 
			option.innerText = name
			option.value = value
		}

		add_parser("Markdown + HTML",		"Markdown"	)
		add_parser("Plaintext + HTML", 		"Text"		)
		add_parser("JavaScript / App", 		"App"		)
		add_parser("JavaScript / Process", 	"Process"	)

		// Hide the editor and type selector
		parser_selector.hidden = true
		editor.hidden = true


		// Export the DOM
		note.dom.header 	= header
		note.dom.body 		= body
		note.dom.editor 	= editor
		note.dom.title 		= title
		note.dom.tools 		= tools
		note.dom.date 		= date
		note.dom.buttons 	= buttons
		note.dom.menu_root 	= menu_root
		note.dom.menu 		= menu

		//
		// STAGE 2: Title and Body functions
		//

		// Enable/disable wrapping in the editor
		function disable_wrap() { editor.style.whiteSpace = "pre" }
		function enable_wrap() { editor.style.whiteSpace = "pre-wrap" }

		function show_editor() {
			editor.hidden = false
			editor.style.height = "calc(" + editor.scrollHeight + "px + 1em)"
			parser_selector.hidden = false
			body.hidden = true
		}

		function hide_editor() {
			editor.value = ""
			editor.style.height = ""
			editor.hidden = true
			parser_selector.hidden = true
			body.hidden = false
		}

		// Handle tab keypresses
		// Kills the undo stack unfortunately
		function editor_keydown(event) {
			if (event.key === "Tab") {
				event.preventDefault()
				utils.insert_at_cursor("\t", this)
			}
		}

		// Adjust the editor height on input
		function editor_resize(event) {
			editor.style.height = editor.scrollHeight + "px"
		}

		editor.onkeydown = editor_keydown
		editor.oninput = editor_resize

		title.onkeypress = function() {
			if (event.key === "Enter") {
				event.preventDefault()
			}
		}

		function set_title(text) 	{ title.innerHTML 	= text }
		function set_date(text) 	{ date.innerHTML 	= text }
		function set_body(text) 	{ body.innerHTML 	= text }

		function scroll_to() {
			note.dom.box.scrollIntoView({behavior: "smooth", block: "nearest"})
		}

		function blink() {
			note.dom.box.classList.add("attention")
			setTimeout(unblink, 50)
		}

		function unblink() {
			note.dom.box.classList.remove("attention")
		}

		function q_sel(selector) {
			return body.querySelector(selector)
		}
		
		//
		// STAGE 3: Toolbar functions
		//

		// Object to house the buttons
		note.buttons = {}

		// Removes all buttons from the toolbar and the menu
		function clear_buttons() {
			for (var name in note.buttons) {
				note.buttons[name].delete_button()
			}
		}

		// Add a button
		// Requires the note to have a handler function with a matching name
		function add_button(name, text, parent) {
			// 1. Create a button
			note.buttons[name] = add("button", parent)

			// 2. Set the name
			note.buttons[name].innerText = text

			// 3. Button deletion function
			note.buttons[name].delete_button = function() {
				note.buttons[name].remove()
				delete note.buttons[name]
			}

			// 4. Handler function
			// Check whether the handler function exists
			// If it does, hook it up
			// Otherwise complain
			if (name in note) {
				note.buttons[name].onclick = note[name]
			} else {
				log("Added a button \"" + text + "\" but couldn't find a handler function!")
			}
		}

		// Helpers to add:
		// 1. A toolbar button
		// 2. A menu button
		function add_toolbar_button(name, text) { add_button(name, text, buttons) }
		function add_menu_button(name, text) 	{ add_button(name, text, menu) }

		// Default toolbar
		// Tools feature the "close", "edit" and "more" buttons (At least for this pathfinder version)
		function display_default_toolbar() {
			clear_buttons()

			add_toolbar_button("more", "More")
			add_toolbar_button("edit", "Edit")
			add_toolbar_button("close", "Close")

			add_menu_button("find_similar", "Find similar notes")
			add_menu_button("export", "Export note")

			if (note.info.archived) {
				add_menu_button("unarchive", "Unarchive note")
			} else {
				add_menu_button("archive", "Archive note")
			}
		}

		// Editing toolbar
		// Tools feature the "delete", "abort" and "save" buttons
		function display_editing_toolbar() {
			clear_buttons()

			add_toolbar_button("delete", "Delete")
			add_toolbar_button("abort", "Abort")
			add_toolbar_button("save", "Save")
		}

		// Temporary note toolbar
		// Only the "close" button
		function display_temporary_toolbar() {
			clear_buttons()

			add_toolbar_button("close", "Close")
		}

		// Suggested note toolbar
		// "Create" and "close" buttons
		function display_suggestion_toolbar() {
			clear_buttons()

			add_toolbar_button("create", "Create")
			add_toolbar_button("close", "Close")
		}

		//
		// STAGE 4: Button handlers
		//
		define_button_handlers()

		function define_button_handlers() {
			// Close the note
			note.close = function() { 
				note.dom.box.remove()

				if ("info" in note) {
					delete entries[note.info.title]
				}
			}

			// Enter editing mode
			note.edit = function() { 
				display_editing_toolbar() 

				// Pull the unprocessed text (pre-markdown or pre-execution)
				var raw_text = core.get_note_text(note.info.title)
				editor.value = raw_text

				title.classList.add("editing")
				title.contentEditable = true

				parser_selector.value = note.info.parser

				show_editor()

				// Focus editor if doing so will not cause the page to scroll
				if (stretches_beyond_viewport(editor) === false) {
					editor.focus()
				}
			}

			// Display more buttons
			note.more = function() { menu.classList.toggle("hide") }

			// Delete the note
			note.delete = function() { 
				var really_delete = confirm("Delete note \"" + note.info.title + "\"\n\nAre you sure?")

				if (really_delete === true) {
					note.close()
					core.delete_note(note.info.title)
				}
			}

			// Abort editing
			note.abort = function() { 
				display_default_toolbar()

				title.contentEditable = false
				title.classList.remove("editing")
				title.innerText = note.info.title
				
				hide_editor()
			}

			// Save edits
			note.save = function() {
				// Harvest the text
				var text = editor.value

				// Harvest the title (old and new)
				var old_title = note.info.title
				var new_title = title.innerText.trim()

				// Hide the editor
				note.abort()

				// Check whether the title was altered
				// If it was, call the rename function
				// alert_all_notes() will update the story
				if (old_title != new_title) {
					core.rename_note(old_title, new_title)
				}

				// Update the parser
				// Take some liberties with altering note fields directly
				// We call set_note_text() regardless, so whatever
				note.info.parser = parser_selector.value
				
				// Update the contents
				// Should trigger an automatic reload
				core.set_note_text(new_title, text)
			}

			// Create button on suggested notes
			note.create = function() { 
				var title_text = title.innerText

				note.info = core.create_note(title_text)
				reload()
				note.edit()
			}

			// Find similar notes
			note.find_similar = function() { 
				var results = search.lunr_find_similar(note.info.title)

				var results_note = story.create_temporary_note(note.info.title)
				var htmlcode = ""
				var len = results.length

				// Display the self-similarity first and foremost
				var entry = results[0]
				htmlcode += "Self-similarity: " + entry.score

				for (var i = 1; i < len; i++) {
					var entry = results[i]
					var tags = search.lunr_auto_tags(entry.title)

					htmlcode += "<div class=\"search_result\"><div>▶ " + utils.display_title(entry.title, note.info.title) + "</div><div>Similarity: " + entry.score + "</div><div>Tags: " + utils.display_tags(tags) + "</div></div>" 
				}

				results_note.set_title("<i>Find similar: " + note.info.title + "</i>")
				results_note.set_body(htmlcode)
				results_note.scroll_to()
			}

			// Export this note in particular
			note.export = function() {
				networking.download(core.export_note(note.info.title), note.info.title + ".jsbit")
			}

			note.archive = function() {
				core.archive_note(note.info.title)
			}

			note.unarchive = function() {
				core.unarchive_note(note.info.title)
			}
		}

		// Reload function 
		// Text notes: 	fetch the text, parse it as markdown and display it
		// App notes: 	fetch the text and run it
		async function reload() {
			var title = note.info.title

			log("Reloading [" + title + "]")

			// Display the default toolbar
			display_default_toolbar()

			// Update the note UI title
			set_title(title)

			// Update the story entry
			entries[title] = note

			var parsers = {
				"Markdown": markdown_parser,
				"Text": text_parser,
				"App": app_loader
			}

			// Missing parser security check
			var target_parser = note.info.parser

			if (target_parser in parsers === false) {
				alert(locale.parser_missing + target_parser)
				target_parser = "Text" // Fall back to plaintext parser
			}

			// Execute the parser
			parsers[target_parser]()

			// Scroll to the note at last
			scroll_to()

			
			// And below are the parser functions
			// =======================================================
			function markdown_parser() {
				if (note.info.archived) {
					set_date( utils.format_time(note.info.modified) + "; Archived")
				} else {
					set_date( utils.format_time(note.info.modified) )
				}

				set_body( markdown.parse(note.info.text, null, note.info.title) )
			}

			function text_parser() {
				if (note.info.archived) {
					set_date( utils.format_time(note.info.modified) + "; Archived")
				} else {
					set_date( utils.format_time(note.info.modified) )
				}
				
				set_body( note.info.text )
			}

			function app_loader() {
				set_date("") // Apps don't show a date by default
				set_body("")

				// On notes with code disable editor wrap by default
				disable_wrap()

				var run = new AsyncFunction("note", note.info.text)
				run(note)
			}
			// =======================================================
		}

	}

	this.handle_anchor_change = function() {
		var target_note = decodeURI(location.hash.slice(1))
		story.open_note(target_note)
	}

	window.onhashchange = story.handle_anchor_change

	// ==============================================================================
}

ias.navbar = function() {
	//
	// IAS GUI; navbar
	//
	// ==============================================================================

	// Alias
	var navbar = this

	navbar.buttons = {}
	navbar.handlers = {}

	navbar.init = function() {
		navbar.button_area = q_sel(".nav_buttons")
		navbar.menu_area = q_sel(".nav_dropdown")
		navbar.search = q_sel(".nav_search")
		navbar.display_default_navbar()

		navbar.search.placeholder = locale.search_placeholder

		navbar.current_theme = "" //"/ias/themes/default"
		navbar.apply_theme()
	}

	navbar.clear = function() {
		for (var name in navbar.buttons) {
			navbar.buttons[name].delete_button()
		}
	}

	// Add a navbar button
	navbar.add_button = function(name, text) {
		// 1. Create a button
		navbar.buttons[name] = add("button", navbar.button_area)

		// 2. Set the name
		navbar.buttons[name].innerText = text

		// 3. Button deletion function
		navbar.buttons[name].delete_button = function() {
			navbar.buttons[name].remove()
			delete navbar.buttons[name]
		}

		// 4. Handler function
		navbar.buttons[name].onclick = navbar.handlers[name]
	}

	navbar.display_default_navbar = function() {
		navbar.clear()

		navbar.add_button("create_new_note", 	"New note")
		navbar.add_button("open_settings", 		"Settings")
		navbar.add_button("save", 				"Save")
		navbar.add_button("switch_theme", 		"Theme")
		navbar.add_button("toggle_more", 		"More")
		navbar.add_button("toggle_search", 		"Search")
	}

	navbar.handlers.create_new_note = 	function() { story.create_new_note() }
	navbar.handlers.open_settings = 	function() { story.open_note("Settings") }
	navbar.handlers.save = 				function() { singlefile_saver.save() }
	navbar.handlers.switch_theme = 		function() { alert("UNIMP") }
	navbar.handlers.toggle_more = 		function() { dropdown.toggle() }
	navbar.handlers.toggle_search = 	function() { story.open_note("Search") }

	// Highlight the save button to warn that you have pending changes
	navbar.post_save_warning = function() { navbar.buttons.save.classList.add("alert") }
	navbar.clear_save_warning = function() { navbar.buttons.save.classList.remove("alert") }

	// Storage alerts handler
	navbar.alert = function(alert, cause) {
		// Activate the "unsaved changes" warning light
		navbar.post_save_warning()

		// If theme changed, re-apply it
		if (alert === "note_altered" && cause === navbar.current_theme) {
			navbar.apply_theme()
		}
	}

	// (Re)apply the theme
	navbar.apply_theme = function() {
		if (core.note_exists(navbar.current_theme)) {
			var css = core.get_note_text(navbar.current_theme)
			utils.apply_css(css)
		} else {
			log("Theme switcher: note [" + navbar.current_theme + "] does not exist")
		}
	}

	// ==============================================================================
}

ias.dropdown = function() {
	//
	// IAS GUI; Dropdown navigation menu
	//
	// ==============================================================================
	
	// Dropdown menu is the menu unveiled by clicking "more" button in the navbar
	//

	// Alias
	var dropdown = this
	var open = false
	var elem

	dropdown.init = function() {
		elem = q_sel(".nav_dropdown")
	}

	dropdown.toggle = function() {
		open = elem.classList.contains("open")

		if (open === false) {
			elem.classList.add("open")
			open = true

			dropdown.update()
		} else {
			elem.classList.remove("open")
			open = false
		}
	}

	dropdown.alert = function(alert, cause) {
		if (open) {
			dropdown.update()
		}
	}

	dropdown.update = function() {
		elem.innerHTML = ""

		elem.innerHTML += dropdown.get_recent_notes()
		elem.innerHTML += dropdown.get_apps()
	}

	dropdown.get_recent_notes = function() {
		var htmlcode = "<h1>Recent notes</h1><hr>"

		var titles = core.get_recent_titles(20)
		var count = titles.length

		for (var i = 0; i < count; i++) {
			htmlcode += dropdown.make_link(titles[i])
		}

		return htmlcode
	}
	
	dropdown.get_apps = function() {
		var htmlcode = "<h1>Apps</h1><hr>"

		var apps 		= core.get_notes_with_field("parser", "App")
		var processes 	= core.get_notes_with_field("parser", "Process")

		var titles = apps.concat(processes)
		var count = titles.length

		for (var i = 0; i < count; i++) {
			htmlcode += dropdown.make_link(titles[i])
		}

		return htmlcode
	}

	dropdown.make_link = function(title) {
		return `<a class="internal auto" href="#${title}" onclick="story.open_note('${title}'); return false;">${title}</a><br>`
	}



	// ==============================================================================
}

ias.networking = function() {
	//
	// IAS networking
	//
	// ==============================================================================

	// Download some data as a file
	this.download = function(data, name) {
		var type = "text/html";
		var blob = new Blob([data], {'type': type});
		var url = URL.createObjectURL(blob);

		var anchor = add("a")

		anchor.href = url
		anchor.download = name

		anchor.click()
		anchor.remove()
	}

	// Upload some data using PUT
	this.put = async function(data, address) {
		var payload = {method: "PUT", body: data}

		try {
			var response = await fetch(address, payload)
		} catch (err) {
			error(locale.network_error)
			return null
		}

		if (response.status === 200 || response.status === 204) {
			var text_response = await response.text()
			return text_response
		} else {
		    error(locale.server_error + "<hr>" + locale.error_code + response.status + "<br>" + locale.address + address)
		    return null
		}
	}

	// Download some data using GET
	// Available types:
	//		text 		Just give the text
	// 		json 		Parse as JSON while skipping the string conversion step
	// 		blob 		Do not parse or attempt to read as string, just give the data. Appears to be broken on mobile chromium.
	//
	// Chromium will fail quietly on very large JSON
	// There's also a way to make it fail loudly:
	// - Download as a blob
	// - Construct a blob URL
	// - Give blob URL to Fetch
	// - Attempt to call response.json()
	//
	// It will crash.
	this.get = function(address, callback_ready, type = "text") {
		var xhr = new XMLHttpRequest();

		xhr.onload = async function() {
			callback_ready(xhr.response)
		}

		xhr.onprogress = function(event) {
			show_status("Downloading [" + address + "]: <br><div class=progress><div class=bar style='width: " + (event.loaded / event.total * 100) + "%;'></div>" + Math.round(event.loaded / 1024) + "KB</div>")
		}

		xhr.onerror = function(event) {
			error(locale.network_error)
		}

		xhr.open('GET', address, true);
		//xhr.overrideMimeType("application/json");
		xhr.responseType = type
		xhr.send(null);
	}
	// ==============================================================================
}

ias.singlefile_saver = function() {
	//
	// IAS saving code
	//
	// ==============================================================================

	// Save as a single HTML file
	// Two endpoints supported:
	// - Browser download
	// - PUT request to server
	//
	// If IAS was loaded via HTTP/HTTPS, save() will automatically switch to PUT.
	// 		Correction: no, it will not, not at this time.
	//

	//
	// List of APIs:
	// - save()
	// - make_banner(text) 				INTERNAL
	// - save_component(name)			INTERNAL
	// - save_all_components()			INTERNAL
	// - save_notes()					INTERNAL
	// - build_file_text()				INTERNAL
	//

	this.make_banner = function(text) {
		return "//\n// " + text + "\n//\n"
	}

	var js_open = "<script>\n\"use strict\";\n\n"
	var js_close = "</" + "script>\n" 

	this.html_template_start = `<!DOCTYPE html>\n<!-- IAS -->\n<!-- JUMP TO BOTTOM OF THE FILE TO FIND THE ENTRY POINT -->\n<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>IAS</title><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="tags.css"></head><body><nav><div class="nav_topbar"><div class="nav_buttons"></div><input type="text" class="nav_search"></div><div class="nav_dropdown"></div></nav><div class="status_area"></div><content><noscript><div class="box"><p>Can't work without JavaScript, unfortunately.</p></div></noscript></content>\n${"<"}script src="lunr.js" type="text/javascript">${"</"}script>\n${js_open}// Source object\n// Stores the source code of the API Servers / components\n// bootloader.init() will initialize them:\n// - ias.core -> window.core\n// - ias.story -> window.story\n// - ias.locale -> window.locale\n// - etc...\n//\n// Only after initialization can you use them!\n//\nvar ias = {}\n${js_close}\n`
	this.html_template_end = `</body></html>`
	this.entry_point_template = `${js_open}${this.make_banner("IAS entry point")}var bootloader = new ias.bootloader()\nbootloader.init()\n${js_close}`


	this.save_component = function(name) {
		return "ias." + name + " = " + ias[name].toString() + "\n\n"
	}

	this.save_all_components = function() {
		var result = ""

		for (var component in ias) {
			result += this.save_component(component)
		}

		return result
	}

	this.save_notes = function() {
		return "window.ias_cold_storage = " + core.cold_storage_snapshot() + "\n\n"
	}

	this.build_file_text = function() {
		var result = ""

		result += js_open + this.save_all_components() + js_close

		result += js_open
		result += this.make_banner("IAS cold storage")
		result += this.save_notes()
		result += js_close

		return this.html_template_start + result + this.entry_point_template + this.html_template_end
	}

	// Save this copy of IAS as a file
	this.save = async function() {
		var protocol = location.protocol
		var pathname = location.pathname

		// For HTTP or HTTPS attempt to save via PUT request
		// Otherwise download a copy to the user's machine
		if (protocol === "http:" || protocol === "https:") {
			var result = await networking.put(this.build_file_text(), pathname)

			if (result === false) {
				error(locale.saving_error)
				return
			}
		} else {
			alert("Warning! External dependencies.\n\nFollowing files are not integrated into the unified HTML at this time:\n - style.css\n - lunr.js\n\nYou'll need to download them separately and place them next to the .html file.")
			networking.download(this.build_file_text(), "ias.html")
		}

		success(locale.saving_ok)
		navbar.clear_save_warning()
	}
	// ==============================================================================
}

ias.search = function() {
	//
	// IAS search
	//
	// ==============================================================================
	
	// Alias
	var search = this

	// Naive full text search
	// Case-insensitive
	search.search_text = function(pattern, ignore_archived = true) {
		var matches = []

		core.for_each_note( function(note) {
			if (ignore_archived && note.archived)
				return

			if (note.text.toLowerCase().includes(pattern))
				matches.push(note.title)
		} )

		return matches
	}

	search.lunr_search_text = function(text, ignore_archived = true) {
		// Initialize if no init yet
		if ("lunr" in search === false) {
			log("Initializing lunr... please hold on")
			search.reinit_lunr()
		}

		var lunr_results = search.lunr.search(text)
		var matches = []
		var len = lunr_results.length

		for (var i = 0; i < len; i++) {
			var id = lunr_results[i].ref
			var note = search.idx._documents[id].note

			if (ignore_archived && note.archived)
				continue

			matches.push(note.title)
		}

		return matches
	}

	// Calculate inverse document frequency for a term if lunr hidden fields are exposed
	search.lunr_idf = function(term) {
		//var term = search.lunr.pipeline.runString(token)

		// Shoddy lunr IDF that takes multiple fields into account and uses some math on top
		// Prime candidate for replacement with a classic version
		return lunr.idf(search.lunr.invertedIndex[term], search.idx.documentCount)
	}

	// Attempt to automatically tag a document
	// Returns 10 top terms
	search.lunr_auto_tags = function(title) {
		var id = search.idx_find_note_id(title)
		var tf = search.idx.fieldTermFrequencies[id]

		var distinct_tems = 0
		var list = {}

		for (var term in tf) {
			var score = tf[term] * search.lunr_idf(term)
			list[term] = score
			distinct_tems++
		}

		var max_tags = Math.min(10, distinct_tems)
		var top = []

		for (var i = 0; i < max_tags; i++) {
			var max_value = 0.0
			var max_term

			for (var term in list) {
				var value = list[term]

				if (value > max_value) {
					max_value = value
					max_term = term
				}
			}

			top.push(max_term)
			delete list[max_term]
		}

		return top
	}

	// Attempt to find documents with a similar document-space vector
	search.lunr_find_similar = function(title) {
		var id = search.idx_find_note_id(title)
		var doc = search.lunr.fieldVectors[id]

		if (doc === undefined) {
			log("Document not found")
			return null
		}

		// Two arrays
		// One keeps scores, the other IDs
		var score_list = []
		var id_list = []

		// Perform a vector dot product with every other document
		for (var other_id in search.lunr.fieldVectors) {
			// Skip self
			if (other_id === id) continue

			var other_doc = search.lunr.fieldVectors[other_id]

			score_list.push( doc.dot(other_doc) )
			id_list.push( other_id )
		}

		// Declare the top 10 (11 actually) array		
		var len = score_list.length
		var top = []

		// First entry is the self-similarity
		var self_similarity = {score: Math.round(doc.dot(doc)), title: title}
		top.push(self_similarity)

		// Sort through all the results and pick out a top 10
		for (var i = 0; i < 10; i++) {
			var max_value = 0.0
			var max_id = 0

			for (var j = 0; j < len; j++) {
				var value = score_list[j]

				if (value > max_value) {
					max_value = value
					max_id = j
				}
			}

			var entry_id = id_list[max_id]
			var entry = {score: Math.round(score_list[max_id]), title: search.idx_get_note_title(entry_id) }
			score_list[max_id] = 0.0

			top.push( entry )
			
		}

		return top
	}

	// Discover neighboring terms
	search.lunr_discover_nearby = function(word) {
		var term = search.lunr.pipeline.runString(word)

		if (term in search.lunr.invertedIndex === false) {
			return null
		}

		var next = []
		var prev = []

		var count = 5
		var idx = search.lunr.invertedIndex[term]._index

		for (var other_term in search.lunr.invertedIndex) {
			var entry = search.lunr.invertedIndex[other_term]
			var delta = idx - entry._index

			if (delta > 0 && delta <= count) {
				prev[count - delta] = other_term
			} else if (delta < 0 && delta >= -count) {
				next[-delta] = other_term
			}
		}

		log(prev.toString().replaceAll(",", " --> ") + " --> " + term + next.toString().replaceAll(",", " --> "))
	}

	// Discover the most common terms amongst all documents
	search.lunr_find_most_common = function(number) {
		var terms = Object.keys(search.lunr.invertedIndex)
		var sm = utils.sortedmap(number)

		for (var term of terms) {
			var count = Object.keys( search.lunr.invertedIndex[term]["a"] ).length
			sm.insert(count, term)
		}

		sm.log()
	}

	// Re-initialize lunr from .idx object
	// Creates following objects:
	// - search.lunr 				The main lunr object
	//
	// Depends on the following:
	// - search.idx.invertedIndex			Index that maps terms to document IDs
	// - search.idx.fieldTermFrequencies	Index that maps document IDs to the distinct terms they contain, plus the encounter rate for each term
	// - search.idx.fieldLengths			Index that maps document IDs to their total term count
	// - search.idx._documents				Index that maps document IDs to whatever metadata was provided
	// - search.idx.documentCount			Integer, total document count
	search.reinit_lunr = function() {
		log("Re-initializing lunr...")

		if ("idx" in search === false) {
			log("No pre-restored/pre-baked indices found! Falling back to generating one from scratch.")
			search.init_lunr_from_notes()
			return
		}

		// Nuke if exists
		delete search.lunr

		search.lunr = lunr(function () {
			// Reset the default pipelines
			this.pipeline.reset()
			this.searchPipeline.reset()

			// Then set them up again but with our custom stemmer
			this.pipeline.add(
				search.unicode_trimmer,
				lunr.stopWordFilter,
				search.partial_stemmer
			)

			this.searchPipeline.add(
				search.partial_stemmer
			)

			// Only one field to index
			// Shortest possible name to use less RAM
			this.field('a')
			this.ref('id')

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex
		})

		log("Complete!")
	}

	// First time search.idx bootstrapping
	// Creates following objects:
	// - search.idx 				A set of primary and secondary indices, some previously hidden
	search.init_lunr_from_notes = function() {
		log("Initializing lunr from scratch...")

		search.lunr = lunr(function () {
			this.pipeline.reset()
			this.searchPipeline.reset()

			this.pipeline.add(
				search.unicode_trimmer,
				lunr.stopWordFilter,
				search.partial_stemmer
			)

			this.searchPipeline.add(
				search.partial_stemmer
			)

			this.field('a')
			this.ref('id')

			// Temporary alias that's visible from within the core.for_each_note()
			var temp_ref = this

			// Growing ID
			var gid = 0

			core.for_each_note(function(note) {
				// Use documentCount to generate IDs
				// Store direct references in _documents
				temp_ref.add({id: gid, a: note.text}, {note: note})
				gid++
			})

			// SHOW ME YOUR GUTS PLEASE
			var idx = (search.idx = {})

			idx.invertedIndex 			= this.invertedIndex
			idx.fieldTermFrequencies 	= this.fieldTermFrequencies
			idx.fieldLengths 			= this.fieldLengths
			idx._documents 				= this._documents
			idx.documentCount 			= this.documentCount
			idx.termIndex 				= this.termIndex
			idx.gid 					= gid
		})
		
		log("Complete!")
	}

	// Delete a single note from the indices without regenerating them completely
	search.idx_delete_note = function(id) {
		var short_id = id.slice(2)

		// Refuse to commit operations that will ruin the index
		if (short_id in search.idx._documents === false) {
			log("No such ID")
			return
		}

		// Mark lunr for reinitialization
		delete search.lunr

		// Delete all records of the note
		var terms = search.idx.fieldTermFrequencies[id]

		for (var term in terms) {
			delete search.idx.invertedIndex[term]["a"][short_id]
		}

		delete search.idx.fieldTermFrequencies[id]
		delete search.idx.fieldLengths[id]
		delete search.idx._documents[short_id]

		search.idx.documentCount--
	}

	// Add a single note into the indices without regenerating them completely
	//
	// Depends on the following:
	// - search.idx.termIndex 				Term insertion counter; _index field of the invertedIndex entries is sampled from this counter
	search.idx_add_note = function(title) {
		// Mark lunr for reinitialization
		delete search.lunr

		var builder_fn = function () {
			this.pipeline.reset()
			this.searchPipeline.reset()

			this.pipeline.add(
				search.unicode_trimmer,
				lunr.stopWordFilter,
				search.partial_stemmer
			)

			this.searchPipeline.add(
				search.partial_stemmer
			)

			this.field('a')
			this.ref('id')

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex

			var note = core.get_note_reference(title)

			this.add({id: search.idx.gid, a: note.text}, {note: note})
			search.idx.gid++

			// Backwards-sync integer variables
			search.idx.documentCount 	= this.documentCount
			search.idx.termIndex 		= this.termIndex
		}

		var builder = new lunr.Builder

		builder_fn.call(builder, builder)

		// [Optional] If you don't want to defer, lunr can be rebuilt right here:
		// search.lunr = builder.build()
	}

	// Iterate through _documents and find the specified title
	// Returns null on failure
	search.idx_find_note_id = function(title) {
		for (var id in search.idx._documents) {
			var doc = search.idx._documents[id]

			if (doc.note.title === title) return ("a/" + id)
		}

		return null
	}

	// Get note title from id
	search.idx_get_note_title = function(id) {
		return search.idx._documents[id.slice(2)].note.title
	}

	// Alert handling
	// Index will be updated in real time to reflect changes in the note storage
	search.alert = function(alert, cause) {
		// Exit if index not initialized; nothing to do, yet!
		if ("idx" in search === false) return
		
		
		// Note creation alerts are not handled because freshly created notes are still empty
		// When a note is first altered is the time to add it

		if (alert === "note_altered") {
			var id = search.idx_find_note_id(cause)

			if (id != null) {
				search.idx_delete_note(id)
			}

			search.idx_add_note(cause)
		}

		if (alert === "note_renamed") {
			// No special handling required
			// We don't store titles in the index
		}

		if (alert === "note_deleted") {
			var id = search.idx_find_note_id(cause)
			search.idx_delete_note(id)
		}
	}

	// This is a lightened version of the lunr stemmer
	// Only steps 1a and 1b remain
	// This matches what is used in the native indexer
	search.partial_stemmer = (function(){
		var step2list = {
		      "ational" : "ate",
		      "tional" : "tion",
		      "enci" : "ence",
		      "anci" : "ance",
		      "izer" : "ize",
		      "bli" : "ble",
		      "alli" : "al",
		      "entli" : "ent",
		      "eli" : "e",
		      "ousli" : "ous",
		      "ization" : "ize",
		      "ation" : "ate",
		      "ator" : "ate",
		      "alism" : "al",
		      "iveness" : "ive",
		      "fulness" : "ful",
		      "ousness" : "ous",
		      "aliti" : "al",
		      "iviti" : "ive",
		      "biliti" : "ble"
		    },

		    step3list = {
		      "icate" : "ic",
		      "ative" : "",
		      "alize" : "al",
		      "iciti" : "ic",
		      "ical" : "ic",
		      "ful" : "",
		      "ness" : ""
		    },

			c = "[^aeiou]",          // consonant
			v = "[aeiouy]",          // vowel
			C = c + "[^aeiouy]*",    // consonant sequence
			V = v + "[aeiou]*",      // vowel sequence

			mgr0 = "^(" + C + ")?" + V + C,						// [C]VC... is m>0
			meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",	// [C]VC[V] is m=1
			mgr1 = "^(" + C + ")?" + V + C + V + C,				// [C]VCVC... is m>1
			mgr2 = "^(" + C + ")?" + V + C + V + C + V + C,		// [C]VCVCVC... is m>2
			s_v = "^(" + C + ")?" + v;							// vowel in stem

		var re_mgr0 = new RegExp(mgr0);
		var re_mgr1 = new RegExp(mgr1);
		var re_mgr2 = new RegExp(mgr2);
		var re_meq1 = new RegExp(meq1);
		var re_s_v = new RegExp(s_v);

		var re_1a = /^(.+?)(ss|i)es$/;
		var re2_1a = /^(.+?)([^s])s$/;
		var re_1b = /^(.+?)eed$/;
		var re2_1b = /^(.+?)(ed|ing)$/;
		var re_1b_2 = /.$/;
		var re2_1b_2 = /(at|bl|iz)$/;
		var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
		var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");

		var re_1c = /^(.+?[^aeiou])y$/;
		var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti)$/;

		var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;

		var re_4 = /^(.+?)(ance|ence|able|ible|ment|iti|ive)$/;


		var porterStemmer = function porterStemmer(w) {
			var stem,
				suffix,
				firstch,
				re,
				re2,
				re3,
				re4;

			if (w.length < 4) { return w; }


			firstch = w.substr(0,1);
			if (firstch == "y") {
			  w = firstch.toUpperCase() + w.substr(1);
			}

			// Step 1a
			re = re_1a
			re2 = re2_1a;

			if (re.test(w)) { w = w.replace(re,"$1$2"); }
			else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }

			// Step 1b
			re = re_1b;
			re2 = re2_1b;
			if (re.test(w)) {
			  var fp = re.exec(w);
			  re = re_mgr0;
			  if (re.test(fp[1])) {
			    re = re_1b_2;
			    w = w.replace(re,"");
			  }
			} else if (re2.test(w)) {
			  var fp = re2.exec(w);
			  stem = fp[1];
			  re2 = re_s_v;
			  if (re2.test(stem)) {
			    w = stem;
			    re2 = re2_1b_2;
			    re3 = re3_1b_2;
			    re4 = re4_1b_2;
			    if (re2.test(w)) { w = w + "e"; }
			    else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
			    else if (re4.test(w)) { w = w + "e"; }
			  }
			}

		    // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)
		    re = re_1c;
		    if (re.test(w)) {
		      var fp = re.exec(w);
		      stem = fp[1];
		      w = stem + "i";
		    }

		    // Step 2
		    re = re_2;
		    if (re.test(w)) {
		      var fp = re.exec(w);
		      stem = fp[1];
		      suffix = fp[2];
		      re = re_mgr0;
		      if (re.test(stem)) {
		        w = stem + step2list[suffix];
		      }
		    }

		    // Step 3
		    re = re_3;
		    if (re.test(w)) {
		      var fp = re.exec(w);
		      stem = fp[1];
		      suffix = fp[2];
		      re = re_mgr0;
		      if (re.test(stem)) {
		        w = stem + step3list[suffix];
		      }
		    }

		    // Step 4
/*		    re = re_4;
			if (re.test(w)) {
				var fp = re.exec(w);
      			stem = fp[1];
      			suffix = fp[2];
      			if (suffix === "iti") {
      				re = re_mgr2;
      			} else {
      				re = re_mgr1;
      			}
      			if (re.test(stem)) {
      				w = stem;
      			}
			}
*/
			// Restore_Y
			re = re_mgr0;
			if (re.test(w)) {
				w = w.replace(/i$/, "y")
			}

			if (firstch == "y") {
			  w = firstch.toLowerCase() + w.substr(1);
			}

			return w;
		};

		return function (token) {
			return token.update(porterStemmer);
		}
	})()

	// Lunr trimmer that was updated to work with Russian characters
	search.unicode_trimmer = function (token) {
		return token.update(function (s) {
			return s.replace(/^[^A-Za-zА-Яа-я0-9ёЁ]+/, '').replace(/[^A-Za-zА-Яа-я0-9ёЁ]+$/, '')
		})
	}

	// ==============================================================================
}

ias.markdown = function() {
	//
	// IAS markdown parser
	//
	// ==============================================================================

	// IAS uses a modified version of snarkdown: 
	// https://github.com/developit/snarkdown
	//
	// The code is baked-in, no external files required
	//

	//
	// List of APIs:
	// - parse(markdown)
	//

	this.parse = function(md, prevLinks, originNote) {
		const TAGS = {
						'_': 	['<i>', '</i>'],
						'__': 	['<b>', '</b>'],
						'*': 	['<b>', '</b>'],
						'**': 	['<i>', '</i>'],
						'___': 	['<b><i>', '</i></b>'],
						'***': 	['<b><i>', '</i></b>'],
						'~~': 	['<s>', '</s>'],
						// '\n': 	['<br>'],
						' ': 	['<br>'],
						'--': 	['<hr>']
					};

		function outdent(str) {
			return str.replace(RegExp('^'+(str.match(/^(\t| )+/) || '')[0], 'gm'), '');
		}

		function encodeAttr(str) {
			return (str+'').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
		}

		let tokenizer = /((?:^---+|\* \*(?: \*)+)\n)|(?:^``` *(\w*)\n([\s\S]*?)\n```$)|(^(?:([>*+-]|\d+\.)\s+.*\n)+)|(?:!\[([^\]]*?)\]\(([^)]+?)\))|(\[)|(\](?:\(([^)]+?)\))?)|(?:^(#{1,6})\s*(.+)\n)|(?:`([^`].*?)`)|(  \n\n*|\*{1,}|_{1,}|~~)|(<[^>]*>)/gm,
			context = [],
			out = '',
			links = prevLinks || {},
			last = 0,
			chunk, prev, token, inner, t;


		function tag(token) {
			let desc = TAGS[token];
			let end = context[context.length-1] == token;
			if (!desc) return token;
			if (!desc[1]) return desc[0];
			if (end) context.pop();
			else context.push(token);
			return desc[end|0];
		}

		function flush() {
			let str = '';
			while (context.length) str += tag(context[context.length-1]);
			return str;
		}

		// Handling for reference-style links
		md = md.replace(/^\[(.+?)\]:\s*(.+)$/gm, (s, name, url) => {
			links[name] = url;
			return '';
		});

		while ( (token=tokenizer.exec(md)) ) {
			prev = md.substring(last, token.index);
			last = tokenizer.lastIndex;
			chunk = token[0];
			if (prev.match(/[^\\](\\\\)*\\$/)) {
				// escaped
			}
			// Code blocks:
			else if (t = token[3]) {
				var language = "";

				// Remove the leading/trailing newline that will likely precede/follow the code within a ``` block
				var code = encodeAttr(t).replace(/^\n+|\n+$/g, '');

				// Set the language if available
				if (token[2]) language = "lang-" + token[2];
				
				chunk = `<code class="${language}">${code}</code>`;
			}
			// > Quotes, -* lists:
			else if (t = token[5]) {
				if (t.match(/\./)) {
					token[4] = token[4].replace(/^\d+/gm, '');
				}
				inner = this.parse(outdent(token[4].replace(/^\s*[>*+.-]/gm, '')));
				if (t=='>') t = 'blockquote';
				else {
					t = t.match(/\./) ? 'ol' : 'ul';
					inner = inner.replace(/^(.*)(\n|$)/gm, '<li>$1</li>');
				}
				chunk = '<'+t+'>' + inner + '</'+t+'>';
			}
			// Images:
			else if (token[7]) {
				chunk = `<img src="${encodeAttr(token[7])}" alt="${encodeAttr(token[6])}">`;
			}
			// Links:
			else if (token[9]) {
				var onclick_attr = ""
				var class_attr = ""

				// Try to extract explicit URL / reference URL
				var url = token[10] || links[prev];

				// Try to make an internal link if no URL specified
				if (!url) {
					url = "#" + prev;
					class_attr = `class="internal"`
					onclick_attr = `onclick="story.open_note('${prev}', '${originNote}'); return false;"`
				}

				out = out.replace('<a>', `<a ${class_attr} href="${encodeAttr(url)}" ${onclick_attr}>`);
				chunk = flush() + '</a>';
			}
			else if (token[8]) {
				chunk = '<a>';
			}
			// Headings:
			else if (token[11]) {
				t = 'h' + token[11].length;
				chunk = '<'+t+'>' + this.parse(token[12], links) + '</'+t+'>';
			}
			// `code`:
			else if (token[13]) {
				chunk = `<code class="inline">${encodeAttr(token[13])}</code>`;
			}
			// Inline formatting: *em*, **strong** & friends
			else if (token[14] || token[1]) {
				chunk = tag(token[14] || '--');
			}
			out += prev;
			out += chunk;
		}

		return (out + md.substring(last) + flush()).replace(/^\n+|\n+$/g, '');
	}

	// ==============================================================================
}

</script>
<script>
"use strict";

//
// IAS cold storage
//
window.ias_cold_storage = [{
title:`minicon`,
text:`
var q_sel = note.q_sel // Alias

var con_htmlcode =
\`
<code id="interactive_console_display" class="long glows blinker"></code>
<textarea id="interactive_console_input"></textarea>
\`

note.set_body(con_htmlcode)

var display = q_sel("#interactive_console_display")
var input = q_sel("#interactive_console_input")

input.style.height = "1.2em"
input.style.width = "100%"
input.style.padding = "0px"
input.style.border = "none"
input.style.color = "white"
input.style.backgroundColor = "#333333"
input.style.overflow = "auto"
input.oninput = input_keyhit

display.style.maxHeight = "15em"
display.innerText += ">"

start_blinker(display)

function input_keyhit() {
	if (input.value.slice(-1) === "\\n") {
		var command = input.value.slice(0, -1)
		input.value = ""

		display.innerText += command + "\\n"

		try {
			display.innerText += Function("return " + command).apply() + "\\n"
		} catch(exception) {
			display.innerText += exception + "\\n"
		}
		
		display.innerText += ">"

		// Scroll to bottom
		display.scrollTo({top: display.scrollHeight, behavior: "smooth"})
	}
}

function start_blinker(console) {
	console.blinker_func = function () {
		console.classList.toggle("blinker")
	}
	
	setInterval(console.blinker_func, 250)
}`,
created:1609225937327,
modified:1609225937327,
parser:`App`
},
{
title:`List of all notes`,
text:`

// Perform initial update
update_list()

// Install the alert handlers
note.alerts.note_created = function() { update_list() }
note.alerts.note_altered = function() { update_list() }
note.alerts.note_renamed = function() { update_list() }
note.alerts.note_deleted = function() { update_list() }

function update_list() {
	var note_list = core.get_recent_titles(core.get_note_count())
	var html_code = ""

	for (var i = 0; i < note_list.length; i++) {
		html_code += make_link(note_list[i]) + "\\n"
	}

	note.set_body(html_code)
}

function make_link(title) {
	return \`<a class="internal" href="#\${title}" onclick="story.open_note('\${title}', '\${note.info.title}'); return false;">\${title}</a>\`
}`,
created:1609225934547,
modified:1609225934547,
parser:`App`
},
{
title:`Export all notes`,
text:`
if (confirm("Download all notes as .json file?")) {
	networking.download(core.cold_storage_snapshot(), "ias_notes.json")
}`,
created:1610375972182,
modified:1610375972182,
parser:`Process`
},
{
title:`Programming guide: search`,
text:`Need to write some comments about:
1. How search initializes and reinitializes
2. Indices present
3. How live deletion/insertion unfolds
4. How apps can utilize the search
`,
created:1611669194920,
modified:1611669194920,
parser:`Markdown`
},
{
title:`Import notes`,
text:`
var imported = 0
var updated = 0

var drop_area = add("div", note.dom.body)

drop_area.classList.add("drag_and_drop_area")
drop_area.innerHTML = "Drop here..."

var file_tip = add("div", note.dom.body)
file_tip.innerText = "Or pick files if you're on mobile: "

var file_input = add("input", file_tip)
file_input.type = "file"

window.ondragenter = function() {
	event.preventDefault()
	drop_area.classList.add("attenting")
}

window.ondragexit = function() {
	event.preventDefault()
	drop_area.classList.remove("attenting")
}

window.ondragover = function() {
	event.preventDefault()
}

drop_area.ondragenter = function() {
	event.preventDefault()
	drop_area.classList.add("ready")
}

drop_area.ondragexit = function() {
	event.preventDefault()
	drop_area.classList.remove("ready")
}

drop_area.ondragover = function() {
	event.preventDefault()
}

drop_area.ondrop = function() {
	event.preventDefault()
	drop_area.classList.remove("attenting")
	drop_area.classList.remove("ready")

	handle_files(event.dataTransfer.files)
}

file_input.oninput = function() {
	event.preventDefault()
	drop_area.classList.remove("attenting")

	handle_files(file_input.files)
	file_input.value = ""
}

// Takes a FileList
function handle_files(files) {
	imported = 0
	updated = 0

	for (var file of files) {
		import_file(file)
	}
}

async function import_file(file) {
	var text = await file.text()

	// A bit of a security nightmare, this
	var obj_fn = new Function("return " + text)
	var obj = obj_fn()

	// Complain if the object is not an object
	if (typeof(obj) !== "object") {
		alert("Import: file [" + file.name + "] did not evaluate into an object.")
	}

	// Array check
	if (Array.isArray(obj)) {
		for (var note of obj) {
			import_note(note)
		}
	} else {
		import_note(obj)
	}
}

function import_note(imported_note) {
	var title = imported_note.title

	if ( core.note_exists(title) ) {
		var note = core.get_note_reference(title)
		var proceed = confirm("Note ["+title+"] already exists.\\nExisting timestamp: "+note.modified+"\\nImported timestamp: "+imported_note.modified+"\\n\\nReplace existing?")

		if (proceed === false) {
			return
		}

		updated++
	} else {
		var note = core.create_note(title)
		imported++
	}

	// Copy the fields
	for (var field of Object.keys(imported_note)) {
		note[field] = imported_note[field]
	}

	// Switch to the Text parser if no parser was set
	if ("parser" in note === false) {
		note.parser = "Text"
	}

	// Convert YYYYMMDDHHMMSSmmm timestamps into classic Unix timestamps
	if (typeof(note.created) === "string") note.created = utils.parse_note_timestamp(note.created)
	if (typeof(note.modified) === "string") note.modified = utils.parse_note_timestamp(note.modified)

	success("Imported " + imported + " notes<br>Updated " + updated + " notes")
}`,
created:1612277030569,
modified:1612277030569,
parser:`App`
},
{
title:`Markdown guide`,
text:`IAS uses a modified version of the Snarkdown Markdown parser. Below is a brief guide on the available syntax.

Click "Edit" to see the source code.

# Text formatting
---
Three font modes are available:
*Bold*
**Italics**
***Bold + Italics*** 

Strike-through mode is available:
~~Example~~
~~*Example*~~
__~~Example~~__

# Code blocks
---
Blocks of code can be made with a triple backtick:

\`\`\`
<script>
	console.log("Hello World!")
</${'script'}>
\`\`\`

There's also \`inline code blocks\` made using a single backtick.

# Links
---
Three types of link syntax are available:

Internal link: [Welcome]
External link: [DuckDuckGo](https://ddg.gg/)
Reference-style link: [Reference 1]

[Reference 1]: https://arxiv.org

# Tables
---
Snarkdown never supported tables, but you can use HTML!

<table>
	<tr>
		<th></th>
		<th>0</th>
		<th>1</th>
		<th>2</th>
		<th>3</th>
	</tr>
	<tr>
		<td>0</td>
		<td>x</td>
		<td>6.7</td>
		<td>31.3</td>
		<td>31.3</td>
	</tr>
	<tr>
		<td>1</td>
		<td>6.7</td>
		<td>x</td>
		<td>31.0</td>
		<td>31.0</td>
	</tr>
	<tr>
		<td>2</td>
		<td>31.3</td>
		<td>31.0</td>
		<td>x</td>
		<td>6.8</td>
	</tr>
	<tr>
		<td>3</td>
		<td>31.3</td>
		<td>31.0</td>
		<td>6.8</td>
		<td>x</td>
	</tr>
</table>

# Images
---
Images can be added using \`![Alt text](URL)\` or via an HTML tag.`,
created:1617529440466,
modified:1617532884260,
parser:`Markdown`
},
{
title:`Programming guide: alert functions`,
text:`IAS features several _alert functions_ that can be used by [Userspace Apps]. Here's the full list:
 - \`note_altered\`				Triggered when some note was altered
 - \`note_renamed\`				Triggered when some note was renamed
 - \`note_deleted\`				Triggered when some note was deleted
 - ... 						...


Here's how an app can hook to an alert function:

\`\`\`
note.alerts.note_deleted = function(cause) { log("Time to update!") }
\`\`\`

Take a look at the \`alert_all_notes()\` of the \`ias_ui\` API server to see how alerts are invoked. Try searching the entire source code for calls to that function to find the places that post various alerts.`,
created:1609838210065,
modified:1618647085131,
parser:`Markdown`
},
{
title:`Programming guide`,
text:`IAS features two application layers:
1. API Servers
2. Userspace Apps

API Servers are stored as raw JavaScript code, and Userspace Apps are stored within notes.

# API Servers
---
Open your browser console and execute \`ias.core.toString()\`

This will print the entire code of the "core" API Server, the one responsible for storing and processing notes. You will notice that the code is wrapped into a function:

\`\`\`
function() {
	// ...
	// ...
	// ...

	this.API_aaa = function() { ... }
	this.API_bbb = function() { ... }
}
\`\`\`

If you are familiar with JavaScript, you will instantly recognize this as the old-school way to create custom types/classes.

A restart is required after editing the code of an API Server.

Take a look at the code of "ias.bootloader" API Server to see how the boot process unfolds.

# Userspace Apps
---
Userspace Apps are stored as notes, and thus to see the code of one of the apps you need to take a different approach: \`core.get_note_text("minicon")\`

This should print the string containing the code of the embedded interactive console app. It is stored as a string, so you will notice some escaped characters.

You will see that it's not wrapped into any functions/objects and is more or less written as your usual JavaScript.

Userspace Apps are executed using a Function() constructor. It provides a degree of encapsulation -- you can declare variables and functions inside, and they will not spill over into the outside world.

Here's the gist of it:

\`\`\`
var run = Function("alert('Hello world!')")
run()
\`\`\`

Every app has access to a \`note\` variable which provides the app with a way to control its note. Here are some of the APIs:

\`\`\`
set_body(text)				Set the body
set_title(text)				Set the title
set_date(text)				Set the date
reload()				Reload the note
scroll_to()				Scroll to the note
...					...
\`\`\`

To turn a note into an app, set its parser to "JavaScript / App" in the editor.

Here's a very simple example app:

\`\`\`
note.set_body("Hello from JavaScript!")
\`\`\`

Apps can freely use any of the API servers available. Let's use the markdown API server to parse some markdown:

\`\`\`
var html = markdown.parse("__Hello world!__\\n---\\nMarkdown parser")
note.set_body(html)
\`\`\`

Try it!`,
created:1609225934547,
modified:1618655797948,
parser:`Markdown`
},
{
title:`Notes of the Day`,
text:`--- Notes of the Day go here ---
---
[System status] / [List of all notes] / [IAS]`,
created:1611675231500,
modified:1618658506006,
parser:`Markdown`
},
{
title:`IAS`,
text:`Hello!

Information Assistance System, or IAS for short, is a system for data storage and organization.

A fusion of a note-taking application, recommender system and a JavaScript scratchpad. A brain extension free from the cloud.

I hope it can find a place in your heart and in your self-hosted infrastructure.`,
created:1614267744062,
modified:1614267744062,
parser:`Markdown`
},
{
title:`Settings`,
text:`// Introduction
var introduction = add("div", note.dom.body)
introduction.innerHTML = "--- Settings go here ---"

// Service
var service = add("div", note.dom.body)
service.innerHTML = "<h1>Service</h1><hr>"

var search_idx_reset_button = add("button", service)
search_idx_reset_button.innerHTML = "Reset search index"
search_idx_reset_button.onclick = reset_search_idx

function reset_search_idx() {
	delete search["lunr"]
	delete search["idx"]
}

service.innerHTML += " - use this button in the event of index consistency violation"`,
created:1619092027364,
modified:1619094022758,
parser:`App`
},
{
title:`Updates`,
text:`> April 30, 2021: [ The Markdown Update ]

Highlights:
 - Add a built-in Markdown parser
	* Significantly modified version of Snarkdown
	* Tuned to be more plaintext-friendly
 - Add a title search independent of lunr.js
	* Matches by title are given higher priority
	* Queries follow boolean AND logic, with space as a separator
	* Results are ordered by last modification date descending
 - Introduced the concept of archived notes
	* Archived notes are invisible to search
 - Introduced the concept of note parsers
	* Plaintext, Markdown, App, Process
	* Fetch and IFrame parsers to come
	* Logic for remote_url notes deleted
 - Style fixes for mobile devices
	* May require you to go and edit the CSS for a smaller font size

Other:
 - Rewrite in the ias.story API server


> March 7, 2021: [ The Pile Update ]

Highlights:
 - Add a gigantic all-encompassing index, along with the infrastructure required to load it
	* No stemming, all words preserved as-is
	* Weighs 777MB
	* Does not work in chromium-based browsers; either fails silently or crashes <a href="https://github.com/chromium/chromium/blob/cc1cde9919f8eaa2e28e6ed61654a67bbf04c89e/third_party/blink/renderer/platform/wtf/allocator/partition_allocator.h#L32">right here</a>. Digging further, this allocator appears to have a hard limit of 2^31 bytes, <a href="https://github.com/chromium/chromium/blob/cc1cde9919f8eaa2e28e6ed61654a67bbf04c89e/base/allocator/partition_allocator/partition_alloc_constants.h#L259">declared here.</a> Sure enough, there's someone <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=416284">complaining about RAM limits in chromium</a>, although it looks like I may be hitting a different bug here.
	* Stored on IPFS
	* Please consider self-hosting to avoid torturing IPFS gateways:
		- Download <a href="https://github.com/a0346f102085fe9f/IAS/archive/master.zip">IAS</a> and <a href="https://gateway.ipfs.io/ipfs/QmYKnbVVwuCC2MDaxnikgZf4Xk12h6gjQquy6DkhJNa1Lo/the_pile.json">The Pile</a> itself
		- Place <kbd>the_pile.json</kbd> into <kbd>idx/</kbd>
		- Run <kbd>index.html</kbd> in Firefox

Other:
 - Show kilobytes downloaded in the progress bar
 - Parse JSON at download-time using <kbd>xhr.responseType = "json"</kbd>

> February 28, 2021: [ IAS Rollup Update 1 ]

Highlights:
 - There is now a download progress bar
 - Search: expose the <kbd>^</kbd> boost postfix
 - Indexer: stemmer improvements
	* Steps 1abc, 2 and 3 now implemented
	* Fixed some previously undiscovered bugs
	* Fixed "poni" and "technologi"
	* 2% decrease in size
 - Indexer: index format was converted to proper JSON, loaded with JSON.parse()
	* Loads much faster
	* No RAM spikes
	* Allows unicode and stuff
	* 26% increase in size... additional syntax really bloats it
 - Indexer: the <kbd>'</kbd> symbol is allowed now
	* Allows to discern between \`luna\` and \`luna's\`.
	* 1% increase in size

Other:
 - Note fields are now closer to what's in TiddlyWiki, allowing some interchangeability
 - Note importing, both IAS format and TiddlyWiki format
 - Support for <kbd>Tab</kbd> key in the editor
 - Fixes to automatic editor resize
 - Wrap toggle in the editor (Not exposed for now)
 
<table>
	<tr>
		<th></th>
		<th>Directories</th>
		<th>Documents</th>
		<th>Size v1.0</th>
		<th>Size v1.1</th>
	</tr>
	<tr>
		<td>Index A</td>
		<td>1</td>
		<td>6337</td>
		<td>53.3M</td>
		<td>65.4M</td>
	</tr>
	<tr>
		<td>Index B</td>
		<td>5</td>
		<td>3908</td>
		<td>46.2M</td>
		<td>56.8M</td>
	</tr>
	<tr>
		<td>Index C</td>
		<td>25</td>
		<td>3218</td>
		<td>46.1M</td>
		<td>56.5M</td>
	</tr>
	<tr>
		<td>Index D</td>
		<td>45</td>
		<td>3360</td>
		<td>47.4M</td>
		<td>58.0M</td>
	</tr>
	<tr>
		<td>Index E</td>
		<td>65</td>
		<td>4426</td>
		<td>49.1M</td>
		<td>60.3M</td>
	</tr>
	<tr>
		<td>Index F</td>
		<td>95</td>
		<td>5590</td>
		<td>48.5M</td>
		<td>59.5M</td>
	</tr>
	<tr>
		<td>Index G</td>
		<td>140</td>
		<td>4618</td>
		<td>49.9M</td>
		<td>61.3M</td>
	</tr>
	<tr>
		<td>Index H</td>
		<td>195</td>
		<td>5545</td>
		<td>49.3M</td>
		<td>60.8M</td>
	</tr>
	<tr>
		<td>Index I</td>
		<td>340</td>
		<td>5319</td>
		<td>49.7M</td>
		<td>61.2M</td>
	</tr>
	<tr>
		<td>Index J</td>
		<td>670</td>
		<td>6270</td>
		<td>49.3M</td>
		<td>60.9M</td>
	</tr>
	<tr>
		<td>Index K</td>
		<td>1826</td>
		<td>5493</td>
		<td>32.0M</td>
		<td>39.7M</td>
	</tr>
</table>


> January 26, 2021: [ Initial release ]
`,
created:1614426404343,
modified:1619789568053,
parser:`Text`
},
{
title:`Welcome`,
text:`Very half-baked software ahead. _There are bugs._
---
[GitHub](https://github.com/a0346f102085fe9f/IAS/) / [Updates] / [IAS]
`,
created:1611675231500,
modified:1619789830450,
parser:`Markdown`
},
{
title:`Search`,
text:`
if ("lunr" in search) {
	show_search_prompt()
} else {
	show_index_download_prompt()
}

function show_index_download_prompt() {
	note.set_body("<p>The search needs to download one of the indexes to work.</p><p>It can take up to a minute to evaluate an index, depending on your device.</p><p>Click one of the buttons below:</p>")

	var indexes = []

	indexes.push( {title: "Index A 	65.4M 	Full Anonymous directory index.", 								url: "idx/index_a.json"} )
	indexes.push( {title: "Index B 	56.8M 	The 5 largest directories, full of non-pony crap.",	 					url: "idx/index_b.json"} )
	indexes.push( {title: "Index C 	56.5M 	Next 25 directories.",	 										url: "idx/index_c.json"} )
	indexes.push( {title: "Index D 	58.0M 	Next 45 directories.",	 										url: "idx/index_d.json"} )
	indexes.push( {title: "Index E 	60.3M 	Next 65 directories.",	 										url: "idx/index_e.json"} )
	indexes.push( {title: "Index F 	59.5M 	Next 95 directories.",	 										url: "idx/index_f.json"} )
	indexes.push( {title: "Index G 	61.3M 	Next 140 directories.",	 										url: "idx/index_g.json"} )
	indexes.push( {title: "Index H 	60.8M 	Next 195 directories.",	 										url: "idx/index_h.json"} )
	indexes.push( {title: "Index I 	61.2M 	Next 340 directories.",	 										url: "idx/index_i.json"} )
	indexes.push( {title: "Index J 	60.9M 	Next 670 directories.",	 										url: "idx/index_j.json"} )
	indexes.push( {title: "Index K 	39.7M 	Next 1826 directories.",	 										url: "idx/index_k.json"} )
	indexes.push( {title: "The Pile 	777.0M 	All of the above.\\n\\t\\t\\t\\tNo stemming.\\n\\t\\t\\t\\tStored on IPFS.\\n\\t\\t\\t\\tNeeds 6.5GB of RAM\\n\\t\\t\\t\\tCrashes chromium-based browsers.", url: "https://gateway.ipfs.io/ipfs/QmYKnbVVwuCC2MDaxnikgZf4Xk12h6gjQquy6DkhJNa1Lo/the_pile.json"} )

	for (var i = 0; i < indexes.length; i++) {
		var index = indexes[i]

		var button = add("button", note.dom.body)
		button.style.textAlign = "start"
		button.innerText = index.title
		button.index_url = index.url
		button.onclick = handle_click

		add("br", note.dom.body)
	}

}

function handle_click(event) {
	download_index(event.target.index_url)
}

async function download_index(url) {

	// Install the search initialization function
	search.init_lunr_from_prebaked = function() {
		log("Lunr prebaked init")

		// All of the stuff should've already been set
		// Except search.idx._documents and gid
		// Manually bitbang some more stuff into existence
		search.idx._documents = {}

		var len = search.idx.documentCount

		for (var i = 0; i < len; i++) {
			var title = search.idx.id_to_filename[i]

			// Can't fetch from poneb.in...
			// Let's simply link then
			var paste_id = (title.slice(title.lastIndexOf("-") + 1)).slice(0, -4)
			var link = "https://poneb.in/" + paste_id

			var note = core.create_note(title)
			note.text = "Open at poneb.in: <a href=\\""+link+"\\">"+link+"</a>\\n\\nThe pastes here... they are too hot for GitHub.\\n\\nCan't fetch from poneb.in directly because \`Access-Control-Allow-Origin: *\` header missing.\\n\\nEven though you see no text, More -> \\"Find similar notes\\" button still functions as intended!"

			search.idx._documents[i] = {note: note}
		}

		search.idx.gid = len

		
		var enable_stemmer = true

		// Very special handling for The Pile
		if (url.endsWith("the_pile.json"))
			enable_stemmer = false


		// Nuke if exists
		delete search.lunr

		search.lunr = lunr(function () {
			// Reset the default pipelines
			this.pipeline.reset()
			this.searchPipeline.reset()

			// Then set them up again, either with or without the stemmer
			if (enable_stemmer) {
				this.pipeline.add(
					lunr.trimmer,
					lunr.stopWordFilter,
					search.partial_stemmer
				)

				this.searchPipeline.add(
					search.partial_stemmer
				)
			} else {
				this.pipeline.add(
					lunr.trimmer,
					lunr.stopWordFilter
				)

				//this.searchPipeline.add()
			}



			// Only one field to index
			// Shortest possible name to use less RAM
			this.field('a')
			this.ref('id')

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex
		})

		log("Complete!")
		log("All OK")
	}


	show_status("Downloading ["+url+"]...")
	var time_dl_start_ms = performance.now()

	networking.get(url, dl_complete, "json")

	function dl_complete(idx) {
		var time_dl_done_ms = performance.now()
		show_status("Download and parsing complete; generating secondary and tertiary indices...")

		search.idx = idx
		search.init_lunr_from_prebaked()

		var time_init_ok_ms = performance.now()

		success("Index installed!<br>" + (time_dl_done_ms - time_dl_start_ms) + "ms to download and parse<br>" + (time_init_ok_ms - time_dl_done_ms) + "ms to initialize lunr")

		show_search_prompt()
	}

}

function show_search_prompt() {
	note.set_body("")

	note.search_field = add("input", note.dom.body)
	note.search_field.placeholder = "Search..."
	note.search_field.type = "text"

	note.search_results_root = add("div", note.dom.body)
	note.search_results = add("div", note.search_results_root)

	note.search_results_root.style.position = "relative"
	note.search_results.style.position = "absolute"

	note.search_results.classList.add("dropdown", "hide")

	note.search_results.onmouseover = lock_results
	note.search_results.onmouseout = unlock_results
	note.search_field.onmouseover = lock_results
	note.search_field.onmouseout = unlock_results

	note.search_field.oninput = handle_input
	note.search_field.onfocus = handle_input

	document.onclick = hide_results
}

var results_locked = 0

function lock_results() { results_locked = 1 }
function unlock_results() { results_locked = 0 }

function show_results() {
	note.search_results.classList.remove("hide")
}

function hide_results() {
	if (results_locked === 0) {
		note.search_results.classList.add("hide")
	}
}

var input_timeout = 0

function handle_input() {
	clearTimeout(input_timeout)

	if (note.search_field.value === "") {
		unlock_results()
		hide_results()
	} else {
		input_timeout = setTimeout(run_search, 250)
	}
}

function run_search() {
	var query = note.search_field.value
	var unsafe_rxp_1 = /\\B\\*\\B/g // Detect stray *
	var unsafe_rxp_2 = /[~^+-]$/g // Detect stray +/-/^/~

	var unsafe = unsafe_rxp_1.test(query) || unsafe_rxp_2.test(query)

	if (unsafe) {
		log("Refusing incomplete/unsafe query")
	} else {
		var title_matches = core.find_titles(query)
		var text_matches = search.lunr_search_text(query)


		note.search_results.innerHTML = format_results(title_matches, text_matches)
		show_results()
	} 
}

function format_results(title_matches, text_matches) {
	var html = ""

	// Optional but will likely benefit performance
	title_matches = title_matches.slice(0, 10)
	text_matches = text_matches.slice(0, 10)


	// Content and/or title matches come first
	if (text_matches.length > 0) {
		var len = Math.min(text_matches.length, 10)

		for (var i = 0; i < len; i++) {
			var title = text_matches[i]
			var tags = search.lunr_auto_tags(title)

			if (title_matches.includes(title)) {
				html += make_entry(title, tags, "📔📖")
			} else {
				html += make_entry(title, tags, "📖")
			}
		}
	}

	// Title only matches come second
	if (title_matches.length > 0) {
		var len = Math.min(title_matches.length, 10)

		for (var i = 0; i < len; i++) {
			var title = title_matches[i]

			if (text_matches.includes(title))
				continue

			var tags = search.lunr_auto_tags(title)

			html += make_entry(title, tags, "📔")
		}
	}


	if (title_matches.length === 0 && text_matches.length === 0) {
		html = "<p>Nothing found...</p>"
	}

	html += "<hr>Prefix words with <kbd>-</kbd> to disallow them, prefix words with <kbd>+</kbd> to make them required. Use <kbd>*</kbd> for unknown letters. Add <kbd>^10</kbd> after the word to multiply the importance by 10, add <kbd>~1</kbd> for fuzzy search with a distance of 1."

	return html
}

function make_entry(title, tags, type) {
	return \`<div class="search_result"><div class="result_title">▶ \${utils.display_title(title, note.info.title)}<span class="flr"><i>\${type}</i></span></div>\${utils.display_tags(tags)}</div>\`
}`,
created:1610984355543,
modified:1619853555732,
parser:`App`
}]

</script>
<script>
"use strict";

//
// IAS entry point
//
var bootloader = new ias.bootloader()
bootloader.init()
</script>
</body></html>
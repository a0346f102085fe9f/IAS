<!DOCTYPE html>
<!-- IAS -->
<!-- JUMP TO BOTTOM OF THE FILE TO FIND THE ENTRY POINT -->
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>IAS</title><link rel="stylesheet" href="night.css"><link rel="stylesheet" href="tags.css"></head><body><nav><div class="nav_topbar"><div class="nav_buttons"></div><input type="text" class="nav_search"></div><div class="nav_dropdown"></div></nav><div class="status_area"></div><content><noscript><div class="box"><p>Can't work without JavaScript, unfortunately.</p></div></noscript></content>
<script src="lunr.js" type="text/javascript"></script>
<script>
"use strict";

// Source object
// Stores the source code of the API Servers / components
// bootloader.init() will initialize them:
// - ias.core -> window.core
// - ias.story -> window.story
// - ias.locale -> window.locale
// - etc...
//
// Only after initialization can you use them!
//
var ias = {}
</script>

<script>
"use strict";

ias.locale = function() {
	//
	// IAS localization strings
	//
	// ==============================================================================
	
	this.date_format = undefined
	this.date_options = {year: "numeric", month: "long", day: "numeric", hour: "numeric", minute: "numeric"}

	this.note_missing = "A note with this title does not yet exist. Use the Create button to create it!"
	this.new_note_title = "Note № "

	this.search_placeholder = "Search..."

	this.saving_error = "Unable to save!"
	this.saving_ok = "Saved."

	this.network_error = "Networking: network error"
	this.server_error = "Networking: server error"
	this.error_code = "Error code: "
	this.address = "Address: "

	this.parser_missing = "This note uses an unknown parser: "

	// ==============================================================================
}

ias.core = function() {
	//
	// IAS core
	//
	// ==============================================================================
	
	// The code to load the notes, save the notes, search the notes, etc...
	// 
	// Each note is an object that features a set of fields;
	// Most importantly:
	// - Title
	// - Text
	// - Created
	// - Modified
	//
	// There's also a set of secondary, optional fields:
	// - Archived Note Flag [Hides the note from the usual search]
	// - System Note Flag 	[Hides the note from the usual search]
	// - List of tags 		[Just an array of tags]
	// - Parser 			[Either "Markdown", "Text", or "App"]
	//
	// Really you can add any field you need, but these are reserved
	//
	
	//
	// List of APIs:
	// - note_exists(title)
	// - create_note(title)
	// - delete_note(title)
	// - rename_note(title, new_title)
	// - get_note_reference(title)
	// - get_note_text(title)
	// - set_note_text(title, text)
	// - for_each_note(callback)
	// - get_oldest_titles(number)
	// - get_recent_titles(number)
	// - get_notes_with_field(field, value)
	// - archive_note(title)
	// - unarchive_note(title)
	// - export_note(title, id)
	// - cold_storage_snapshot()
	// - cold_storage_restore()
	// - float_to_bottom(title)					INTERNAL
	// - update_title_hashmap()					INTERNAL
	// - fire_alert()							INTERNAL
	//
	
	// Async Function Constructor
	// A bit of a hidden feature, but seems to have been supported for a long time
	window.AsyncFunction = Object.getPrototypeOf(async function(){}).constructor
	
	// Note storage
	// WARNING: reveal_pointers() needs to be called again if one of the variables is ever reassigned!
	//
	// notes	[id => note_object] 	always sorted note.modified ASCENDING
	// titles	{note_title => id}		not sorted
	var notes = []
	var titles = {}
	

	// Check whether a note by this title exists
	this.note_exists = function(title) {
		return (title in titles)
	}

	// Create a new note
	this.create_note = function(title) {
		var note = {}
		
		// Check if a note by this title already exists
		if (titles[title] != undefined) {
			log("Tried to create a note ["+title+"] but it already exists!")
			return null
		}
		
		note.title 		= title
		note.text 		= ""
		note.created 	= Date.now()
		note.modified 	= Date.now()
		note.parser 	= "Markdown"
		
		var id = notes.push(note) - 1
		titles[title] = id

		this.fire_alert("note_created", title)
		
		return note
	}

	// Delete the note
	// Will leave holes in the notes array, but that's okay
	// It will be flattened upon saving
	this.delete_note = function(title) {
		var id = titles[title]
		
		delete titles[title]
		delete notes[id]

		this.fire_alert("note_deleted", title)
	}

	// Rename the note
	// Will leave holes in the note array
	this.rename_note = function(title, new_title) {
		var id = titles[title]
		var note = notes[id]

		delete titles[title]

		// Punch holes only if necessary
		if (id < notes.length - 1) {
			delete notes[id]

			id = notes.push(note) - 1
		}

		note.title = new_title
		titles[new_title] = id
		note.modified = Date.now()

		this.fire_alert("note_renamed", title)
	}

	// Get the total note count
	// Doesn't count holes
	this.get_note_count = function() {
		var count = 0

		for (var title in titles) {
			count++
		}

		return count
	}

	// Fetch a reference to the note
	// * Low level function!
	// * Fields may not be populated
	// * DO NOT, NEVER write any fields directly
	// [Potential place to implement a one-deep cache later]
	this.get_note_reference = function(title) {
		var id = titles[title]
		var note = notes[id]

		return note
	}
	
	// Fetch the note text only
	this.get_note_text = function(title) {
		var note = this.get_note_reference(title)

		return note.text
	}

	// Set the note text only
	this.set_note_text = function(title, text) {
		var note = this.get_note_reference(title)

		note.text = text
		note.modified = Date.now()

		this.float_to_bottom(title)
		this.fire_alert("note_altered", title)
	}
	
	// Iterate over each note and call the callback
	// * Supports async functions
	this.for_each_note = function(callback) {
		for (var note of notes) {
			if (note != undefined) callback(note)
		}
	}

	// Returns an array of titles that match the pattern
	// * Pattern uses space as a separator
	// * Case-insensitive
	//
	// If [pattern] is an empty string, returns a list of all notes
	// [ignore_archived] is still taken into account
	this.find_titles = function(pattern, ignore_archived = true) {
		var note_list = []
		var bits = pattern.toLowerCase().split(" ")

		for (var title in titles) {
			var note = this.get_note_reference(title)

			if (note.archived && ignore_archived) {
				continue
			}

			if (!pattern) {
				note_list.push(title)
				continue
			}

			var lowercase_title = title.toLowerCase()
			var nope = false

			for (var bit of bits) {
				if (lowercase_title.includes(bit) === false) {
					nope = true
					break
				}
			}

			if (nope) {
				continue
			} else {
				note_list.push(title)
			}
		}

		return note_list
	}

	// Returns an array no longer than [number]
	this.get_oldest_titles = function(number) {
		var note_list = []
		var len = notes.length

		for (var j = 0, i = 0; (i < len) && (j < number);) {
			if (i in notes) { // Skip over holes
				note_list.push(notes[i].title)
				j++
			}
			i++
		}

		return note_list
	}

	// Returns an array no longer than [number]
	this.get_recent_titles = function(number) {
		var note_list = []

		for (var j = 0, i = notes.length - 1; (i >= 0) && (j < number);) {
			if (i in notes) { // Skip over holes
				note_list.push(notes[i].title)
				j++
			}
			i--
		}

		return note_list
	}

	// Get notes that contain a certain [field] with certain [value]
	// If [value] is not specified, will count any note that has the field
	this.get_notes_with_field = function(field, value = null) {
		var note_list = []
		var len = notes.length

		for (var i = 0; i < len; i++) {
			if (i in notes) {
				if (field in notes[i]) {
					if (value === null) {
						note_list.push(notes[i].title)
					} else if (value === notes[i][field]) {
						note_list.push(notes[i].title)
					}
				}
			}
		}

		return note_list
	}

	this.archive_note = function(title) {
		var note = this.get_note_reference(title)

		if (!note.archived) {
			note.archived = true
			this.fire_alert("note_altered", title)
		}
	}

	this.unarchive_note = function(title) {
		var note = this.get_note_reference(title)

		if (note.archived) {
			delete note["archived"]
			this.fire_alert("note_altered", title)
		}
	}

	// Export a note by a title or by id
	this.export_note = function(title, id = null) {
		if (id === null) id = titles[title]

		var note_json = ""
		var note = notes[id]

		for (var field in note) {
			var value = note[field]
			var type = typeof(value)
			var wrap = ""
			
			if (type === "string") {
				wrap = "`"

				// Replace certain symbols that interfere with JavaScript's multiline strings
				// [ \ ] 	-> [ \\ ]
				// [ ` ] 	-> [ \` ]
				// [ ${ ] 	-> [ \${ ]
				// Also break up any script closing tags
				value = value.
				replaceAll("\\", "\\\\").
				replaceAll("`", "\\`").
				replaceAll("${", "\\${").
				replaceAll("</"+"script>", "</${'script'}>")
			}
			
			if (note_json.length != 0) note_json += ",\n"
			
			note_json += field + ":" + (wrap + value + wrap)
		}

		return "{\n" + note_json + "\n}"
	}
	
	// Generate a string of JS code that will replicate the note storage memory structure
	// Holes are removed
	this.cold_storage_snapshot = function() {
		var result = ""
		
		for (var id = 0; id < notes.length; id++) {
			if (id in notes === false) continue

			var note_json = this.export_note(null, id)
			
			if (result.length != 0) result += ",\n"
			result += note_json
		}
		
		return "[" + result + "]"
	}
	
	// Restore from an already evaluated snapshot
	this.cold_storage_restore = function() {
		notes = ias_cold_storage
		this.update_title_hashmap()
	}

	// Float the note to bottom
	// Will leave holes in the note array
	// Used as a mechanism to fight excessive truncation
	this.float_to_bottom = function(title) {
		var id = titles[title]
		
		// Return if note is already at the bottom
		if (id === notes.length - 1) {
			return
		}

		var note = notes[id]

		delete notes[id]

		var new_id = notes.push(note) - 1
		titles[title] = new_id
	}
	
	// Needs to be called after restoring from snapshot
	this.update_title_hashmap = function() {
		for (var id = notes.length - 1; id >= 0; id--) {
			var title = notes[id].title
			titles[title] = id
		}
	}

	// Fire this to alert things that note storage was modified
	//
	// Currently supported alerts
	// - note_created
	// - note_altered
	// - note_renamed
	// - note_deleted
	//
	this.fire_alert = function(alert, cause) {
		story.alert(alert, cause)
		story.alert_all_notes(alert, cause)

		search.alert(alert, cause)
		navbar.alert(alert, cause)
		dropdown.alert(alert, cause)
	}

	// Reveal or update debug pointers
	this.reveal_pointers = function() {
		this.notes = notes
		this.titles = titles
	}
	// ==============================================================================
}

ias.bootloader = function() {
	//
	// IAS bootloader
	//
	// ==============================================================================
	this.init = function() {
		window.onerror = this.handle_error
		window.onunhandledrejection = this.handle_error
		window.log = console.log

		// Initialize an instance of EVERYTHING that was added into window.ias
		for (var component in ias) {
			window[component] = new ias[component]
		}

		// Restore notes from cold storage, then delete the original reference
		core.cold_storage_restore()
		delete window.ias_cold_storage

		// Initial app start
		navbar.init()
		dropdown.init()

		story.open_note("Welcome")
		story.open_note("Search")

		// Check whether the URL is clean of anchors
		// If yes, open the default note
		// Otherwise, open the linked note
		if (location.hash === "") {
			//story.open_note( default_note )
		} else {
			story.open_note( decodeURI(location.hash.slice(1)) )
		}

	}

	// JavaScript error handler
	this.handle_error = function(description, url, line, column, error) {
		if ("crash_count" in window === false) {
			window.crash_count = 0
		}

		crash_count++

		// Special handling for errors that occured within Async functions
		// Seems to be Firefox-specific to consider async errors promise rejections
		// Chromium considers async errors normal errors
		if (typeof(description) === "object") {
			if ("reason" in description) {
				var reason = description.reason

				description = reason.message
				url = reason.fileName
				line = reason.lineNumber
				column = reason.columnNumber
				error = {}
				error.stack = reason.stack
			}
		}

		var stack_trace = ""

		if (!error) {
			stack_trace = " --- NO ERROR INFO AVAILABLE --- "
		} else if ("stack" in error === false) {
			stack_trace = " --- NO STACK TRACE AVAILABLE --- "
		} else {
			// Firefox specific prettyfication
			// Doesn't break chromium
			stack_trace = error.stack.replace(/\n@/g, "\nanonymous@").replace(/@/g, "   @   ").replace(/\n/g, "\n\t")
		}

		var message = ""
		+ " === Crash report #" + crash_count + " === \n"
		+ "A crash has occurred in:\n"
		+ "<"+url+">:"+line+" --- " + description + "\n\n"
		+ "Stack trace: \n	" + stack_trace + "\n\n"
		+ "A restart is advised.\n\n"
		
		alert(message)
	}

	this.hash = "aaaaad0b03231ca27d61173c145a3b3c18b977b4742de578710fab0478251ae0"
	// ==============================================================================
}

ias.utils = function() {
	//
	// IAS misc utils
	//
	// ==============================================================================

	// List of APIs:
	// - q_id(...)
	// - q_sel(...)
	// - add(tagname, parent, id)
	// - adjacent_add(tagname, target, where, id)
	// - dom_reverse_traverse(element, target_tag)
	// - strectes_beyond_viewport(element)
	// - error(text)
	// - success(text)
	// - show_status(text)
	// - hide_status()
	// - format_time(timestamp)
	// - get_new_title()
	// - apply_css(css)
	// - display_tags(tags)
	// - display_tag(tag)
	//

	// Alias
	var utils = this

	// Query ID alias
	window.q_id = document.getElementById.bind(document)

	// Query selector alias
	window.q_sel = document.querySelector.bind(document)
	
	// Make an element helper
	window.add = function(tagname, parent = document.body, id = null) {
		var element = document.createElement(tagname)
		
		if (id != null) element.id = name
		parent.appendChild(element)
		
		return element
	}

	// Make an adjacent element helper
	// Where can be:
	// - beforebegin
	// - afterbegin
	// - beforeend
	// - afterned
	window.adjacent_add = function(tagname, target, where = "beforebegin", id = null) {
		var element = document.createElement(tagname)
		
		if (id != null) element.id = name
		target.insertAdjacentElement(where, element)
		
		return element
	}

	// Walk up the DOM tree until a <TARGET_TAG> element is found
	// Note: target tag must be in ALL CAPS
	window.dom_reverse_traverse = function(element, target_tag) {
		// Reached the absolute top
		if ("parentElement" in element === false) {
			return false
		}

		if (element.parentElement.tagName === target_tag) {
			return element
		} else {
			return dom_reverse_traverse(element.parentElement, target_tag)
		}
	}

	// Check if a part of the element, or the entire element, stretches beyond the viewport
	window.stretches_beyond_viewport = function(element) {
		return (window.innerHeight + window.scrollY < element.offsetTop + element.scrollHeight)
	}

	// Bring user attention to the element by briefly flashing it in bright color
	window.blink = function(element) {
		element.classList.add("attention")
		setTimeout(unblink, 50)

		function unblink() {
			element.classList.remove("attention")
		}
	}

	window.error = function(text) {
		show_status(text)

		statusbox.classList.add("error")
	}

	window.success = function(text) {
		show_status(text)

		statusbox.classList.add("success")
		setTimeout(hide_status, 5000)
	}

	// Display a status box in the status area
	window.show_status = function(text) {
		if ("statusbox" in window === false) {
			window.statusbox = add("div", q_sel("body .status_area"))
			statusbox.classList.add("status_box")
		}
		
		statusbox.classList.remove("success")
		statusbox.classList.remove("error")
		statusbox.classList.remove("hide")
		statusbox.innerHTML = text

		statusbox.onclick = hide_status
	}

	window.hide_status = function() {
		statusbox.classList.add("hide")
	}

	// https://stackoverflow.com/a/34278578
	utils.insert_at_cursor = function(text, element) {
		var start = element.selectionStart
		var end = element.selectionEnd
		
		element.setRangeText(text, start, end, 'end');
	}

	// Parse a YYYYMMDDHHMMSSmmm TiddlyWiki-style timestamp into a millisecond Unix timestamp
	utils.parse_note_timestamp = function(note_timestamp) {
		var str = note_timestamp.toString()

		var year 	= parseInt( str.slice( 0,  4) )
		var month 	= parseInt( str.slice( 4,  6) ) - 1
		var day 	= parseInt( str.slice( 6,  8) )
		var hour 	= parseInt( str.slice( 8, 10) )
		var minute 	= parseInt( str.slice(10, 12) )
		var second 	= parseInt( str.slice(12, 14) )
		var ms 		= parseInt( str.slice(14, 17) )

		return Date.UTC(year, month, day, hour, minute, second, ms)
	}

	// Convert Unix millisecond timestamp into a YYYYMMDDHHMMSSmmm format
	utils.make_note_timestamp = function(timestamp) {
		var date = new Date(timestamp)

		var year 	= ( date.getUTCFullYear() 		).toString()
		var month 	= ( date.getUTCMonth() + 1		).toString().padStart(2, "0")
		var day 	= ( date.getUTCDate()			).toString().padStart(2, "0")
		var hour 	= ( date.getUTCHours() 			).toString().padStart(2, "0")
		var minute 	= ( date.getUTCMinutes() 		).toString().padStart(2, "0")
		var second 	= ( date.getUTCSeconds() 		).toString().padStart(2, "0")
		var ms 		= ( date.getUTCMilliseconds()	).toString()

		return year+month+day+hour+minute+second+ms
	}

	// Converts supplied timestamp to local format
	utils.format_time = function(timestamp) {
		return new Date(timestamp).toLocaleString(locale.date_format, locale.date_options)
	}

	// Return a title for a new note
	// If the title it wanted to suggest is already occupied, it will recurse to the closest unused number
	utils.get_new_title = function(depth = 1) {
		var title = locale.new_note_title + (core.get_note_count() + depth)

		if (core.note_exists(title)) {
			return utils.get_new_title(depth + 1)
		} else {
			return title
		}
	}

	// Switch to a new CSS
	// Alters the href of the first stylesheet
	utils.apply_css = function(href) {
		var stylesheet = q_sel("link[rel=\"stylesheet\"]")

		stylesheet.setAttribute("href", href)
	}

	// Format an array of tags into a set of pillows
	utils.display_tags = function(tags) {
		var html = "<span class=\"tag_list\">"
		var len = tags.length

		for (var i = 0; i < len; i++)
			html += utils.display_tag(tags[i])

		return html + "</span>"
	}

	// Format a single tag into a <span> pillow
	utils.display_tag = function(tag) {
		// Ignore empty tags
		if (tag === "")
			return ""

		// Regular expression to detect symbols not safe to place inside an HTML attribute
		var rxp_unsafe = /[^A-Za-zА-Яа-я0-9ёЁ_\-]/g

		var safe_tag_attr = tag.replace(rxp_unsafe, "")
		var safe_tag_text = tag.replace(/>/g, "&gt;").replace(/</g, "&lt;")

		return "<span class=\"tag tg-" + safe_tag_attr + "\">" + safe_tag_text + "</span>"
	}

	// Deterministic random number generator
	// Required for Notes of the Day functionality
	utils.seed_prng = function(seed) {
		utils.prng = xoshiro128ss(seed, seed, seed, seed)

		// All 4 state variables were initialized with the same value
		// Need to flush 4 times to start producing good random
		utils.prng()
		utils.prng()
		utils.prng()
		utils.prng()

		// https://github.com/bryc/code/blob/master/jshash/PRNGs.md
		function xoshiro128ss(a, b, c, d) {
			return function() {
				var t = b << 9, r = a * 5; r = (r << 7 | r >>> 25) * 9;
				c = c ^ a; d = d ^ b; b = b ^ c; a = a ^ d; c = c ^ t;
				d = d << 11 | d >>> 21;
				return (r >>> 0) / 4294967296;
			}
		}
	}

	utils.prng = function() {
		return "Please call seed_prng() first"
	}

	// DIY map with fixed number of slots
	// Relies on the fact that browsers sort object keys alphabetically
	// Will break if they ever stop doing that
	utils.sortedmap = function(slots) {
		var sm = {}

		var map = {}
		var len = 0

		// Insert a value - object pair
		sm.insert = function(value, object) {
			var min = null

			for (var value_i in map) {
				min = value_i
				break
			}

			if (min === null) {
				map[value] = object
				return
			}

			if (len == slots) {
				if (value < min) return
				if (value in map === false) delete map[min]
			} else {
				if (value in map === false) len++
			}

			map[value] = object
		}

		// Print out the map
		sm.log = function() {
			log(map)
		}

		sm.map = map

		return sm
	}
	// ==============================================================================
}

ias.cardnote = function() {
	//
	// IAS GUI; card-based notes
	//
	// ==============================================================================
	
	//
	// This is a large monolithic blob respobsible for:
	// - Note HTML structure
	// - Note interactions
	// - App startup
	// - Parsers
	//
	// A lot of uniqe code is buried somewhere in there, for example handlers for
	// "Find similar notes" button and the .jsbit export function
	//

	//
	// List of APIs:
	// - set_title(text)
	// - set_date(text)
	// - set_body(text)
	// - scroll_to()
	// - blink()
	// - q_sel(selector)
	// - link(title)
	// - editor.disable_wrap()
	// - editor.enable_wrap()
	// - toolbar.display_default_toolbar()						TOOLBAR PRESET
	// - toolbar.display_editing_toolbar()						TOOLBAR PRESET
	// - toolbar.display_temporary_toolbar()					TOOLBAR PRESET
	// - toolbar.display_suggestion_toolbar()					TOOLBAR PRESET
	// - toolbar.add_toolbar_button(name, text)
	// - toolbar.add_menu_button(name, text)
	// - toolbar.clear_buttons()
	// - more()											BUTTON HANDLER
	// - edit()											BUTTON HANDLER
	// - close()										BUTTON HANDLER
	// - delete()										BUTTON HANDLER
	// - abort()										BUTTON HANDLER
	// - save()											BUTTON HANDLER
	// - create()										BUTTON HANDLER
	// - archive()										BUTTON HANDLER
	// - unarchive()									BUTTON HANDLER
	// - reload()
	//
	this.define_note = function(note) {
		// STAGE 0: Exports

		// Various top-level stuff
		note.set_title = set_title
		note.set_date = set_date
		note.set_body = set_body
		note.scroll_to = scroll_to
		note.blink = blink
		note.q_sel = q_sel
		note.link = link

		// Editor subfolder
		note.editor = {}
		note.editor.disable_wrap = disable_wrap
		note.editor.enable_wrap = enable_wrap

		// Toolbar subfolder
		note.toolbar = {}
		note.toolbar.display_default_toolbar = display_default_toolbar
		note.toolbar.display_editing_toolbar = display_editing_toolbar
		note.toolbar.display_temporary_toolbar = display_temporary_toolbar
		note.toolbar.display_suggestion_toolbar = display_suggestion_toolbar
		note.toolbar.add_toolbar_button = add_toolbar_button
		note.toolbar.add_menu_button = add_menu_button
		note.toolbar.clear_buttons = clear_buttons

		note.reload = reload

		// Alert handlers
		note.alerts = {}

		// Lists to track usage of setInterval and setTimeout
		note.held_intervals = []
		note.held_timeouts = []

		// Expose this function
		// Search can use it to abort pending jobs
		note.timer_cleanup = timer_cleanup

		//
		// STAGE 1: Structure
		//

		// It all starts with a box
		var box = note.dom.box

		// Note consist of the top, the body and the (hidden) editor
		var top 		= add("div", box)
		var body 		= add("div", box)
		var editor		= add("textarea", box)

		// Top
		// -> Header
		//    -> Title
		//    -> Tools
		// -> Date
		var header 		= add("div", top)
		var title 		= add("div", header)
		var tools 		= add("div", header)
		var date 		= add("div", top)

		// Div to store toolbar buttons
		var buttons 	= add("div", tools)

		// More menu
		var menu_root 	= add("div", tools)
		var menu 		= add("div", menu_root)

		// Set up CSS classes
		header.classList.add("note_header")
		editor.classList.add("note_editor")
		title.classList.add("note_title")
		tools.classList.add("note_tools")
		date.classList.add("note_date")
		body.classList.add("note_body")

		menu_root.classList.add("dropdown_root")
		menu.classList.add("dropdown", "hide")

		// Parser selector
		var parser_selector = add("select", box)

		function add_parser(name, value) { 
			var option = add("option", parser_selector) 
			option.innerText = name
			option.value = value
		}

		add_parser("Markdown + HTML",		"Markdown"	)
		add_parser("Plaintext + HTML", 		"Text"		)
		add_parser("JavaScript / App", 		"App"		)
		add_parser("Remote / Iframe", 		"Iframe"	)

		// Hide the editor and type selector
		parser_selector.hidden = true
		editor.hidden = true


		// Export the DOM
		note.dom.header 	= header
		note.dom.body 		= body
		note.dom.editor 	= editor
		note.dom.title 		= title
		note.dom.tools 		= tools
		note.dom.date 		= date
		note.dom.buttons 	= buttons
		note.dom.menu_root 	= menu_root
		note.dom.menu 		= menu

		//
		// STAGE 2: Title and Body functions
		//

		// Enable/disable wrapping in the editor
		function disable_wrap() { editor.style.whiteSpace = "pre" }
		function enable_wrap() { editor.style.whiteSpace = "pre-wrap" }

		function show_editor() {
			editor.hidden = false
			editor.style.height = "calc(" + editor.scrollHeight + "px + 1em)"
			parser_selector.hidden = false
			body.hidden = true
		}

		function hide_editor() {
			editor.value = ""
			editor.style.height = ""
			editor.hidden = true
			parser_selector.hidden = true
			body.hidden = false
		}

		// Handle tab keypresses
		// Kills the undo stack unfortunately
		function editor_keydown(event) {
			if (event.key === "Tab") {
				event.preventDefault()
				utils.insert_at_cursor("\t", this)
			}
		}

		// Adjust the editor height on input
		function editor_resize(event) {
			editor.style.height = editor.scrollHeight + "px"
		}

		editor.onkeydown = editor_keydown
		editor.oninput = editor_resize

		title.onkeypress = function() {
			if (event.key === "Enter") {
				event.preventDefault()
			}
		}

		function set_title(text) 	{ title.innerHTML 	= text }
		function set_date(text) 	{ date.innerHTML 	= text }
		function set_body(text) 	{ body.innerHTML 	= text }

		function scroll_to() {
			note.dom.box.scrollIntoView({behavior: "smooth", block: "nearest"})
		}

		function blink() {
			window.blink(note.dom.box)
		}

		function q_sel(selector) {
			return body.querySelector(selector)
		}

		// Use this to link to other notes
		// Returns a special HTML snippet that has an onclick handler for ensuring that linked note opens right below the origin note
		function link(title) {
			var safe_openafter = note.info.title.replace(/'/g, "\\'")
			var safe_title = title.replace(/'/g, "\\'")

			return `<a class="internal" href="#${title}" onclick="story.open_note('${safe_title}', '${safe_openafter}'); return false;">${title}</a>`
		}
		
		//
		// STAGE 3: Toolbar functions
		//

		// Object to house the buttons
		note.buttons = {}

		// Removes all buttons from the toolbar and the menu
		function clear_buttons() {
			for (var name in note.buttons) {
				note.buttons[name].delete_button()
			}
		}

		// Add a button
		// Requires the note to have a handler function with a matching name
		function add_button(name, text, parent) {
			// 1. Create a button
			note.buttons[name] = add("button", parent)

			// 2. Set the name
			note.buttons[name].innerText = text

			// 3. Button deletion function
			note.buttons[name].delete_button = function() {
				note.buttons[name].remove()
				delete note.buttons[name]
			}

			// 4. Handler function
			// Check whether the handler function exists
			// If it does, hook it up
			// Otherwise complain
			if (name in note) {
				note.buttons[name].onclick = note[name]
			} else {
				log("Added a button \"" + text + "\" but couldn't find a handler function!")
			}
		}

		// Helpers to add:
		// 1. A toolbar button
		// 2. A menu button
		function add_toolbar_button(name, text) { add_button(name, text, buttons) }
		function add_menu_button(name, text) 	{ add_button(name, text, menu) }

		// Default toolbar
		// Tools feature the "close", "edit" and "more" buttons (At least for this pathfinder version)
		function display_default_toolbar() {
			clear_buttons()

			add_toolbar_button("more", "More")
			add_toolbar_button("edit", "Edit")
			add_toolbar_button("close", "Close")

			add_menu_button("find_similar", "Find similar notes")
			add_menu_button("export", "Export note")

			if (note.info.archived) {
				add_menu_button("unarchive", "Unarchive note")
			} else {
				add_menu_button("archive", "Archive note")
			}
		}

		// Editing toolbar
		// Tools feature the "delete", "abort" and "save" buttons
		function display_editing_toolbar() {
			clear_buttons()

			add_toolbar_button("delete", "Delete")
			add_toolbar_button("abort", "Abort")
			add_toolbar_button("save", "Save")
		}

		// Temporary note toolbar
		// Only the "close" button
		function display_temporary_toolbar() {
			clear_buttons()

			add_toolbar_button("close", "Close")
		}

		// Suggested note toolbar
		// "Create" and "close" buttons
		function display_suggestion_toolbar() {
			clear_buttons()

			add_toolbar_button("create", "Create")
			add_toolbar_button("close", "Close")
		}

		//
		// STAGE 4: Button handlers
		//
		define_button_handlers()

		function define_button_handlers() {
			// Close the note
			note.close = function() {
				timer_cleanup()

				note.dom.box.remove()

				if ("info" in note) {
					story.remove_instance(note, note.info.title)
				}
			}

			// Enter editing mode
			note.edit = function() { 
				display_editing_toolbar() 

				// Pull the unprocessed text (pre-markdown or pre-execution)
				var raw_text = core.get_note_text(note.info.title)
				editor.value = raw_text

				title.classList.add("editing")
				title.contentEditable = true

				parser_selector.value = note.info.parser

				show_editor()

				// Focus editor if doing so will not cause the page to scroll
				if (stretches_beyond_viewport(editor) === false) {
					editor.focus()
				}
			}

			// Display more buttons
			note.more = function() { menu.classList.toggle("hide") }

			// Delete the note
			note.delete = function() { 
				var really_delete = confirm("Delete note \"" + note.info.title + "\"\n\nAre you sure?")

				if (really_delete === true) {
					note.close()
					core.delete_note(note.info.title)
				}
			}

			// Abort editing
			note.abort = function() { 
				display_default_toolbar()

				title.contentEditable = false
				title.classList.remove("editing")
				title.innerText = note.info.title
				
				hide_editor()
			}

			// Save edits
			note.save = function() {
				// Harvest the text
				var text = editor.value

				// Harvest the title (old and new)
				var old_title = note.info.title
				var new_title = title.innerText.trim()

				// Hide the editor
				note.abort()

				// Check whether the title was altered
				// If it was, call the rename function
				// alert_all_notes() will update the story
				if (old_title != new_title) {
					core.rename_note(old_title, new_title)
				}

				// Update the parser
				// Take some liberties with altering note fields directly
				// We call set_note_text() regardless, so whatever
				note.info.parser = parser_selector.value
				
				// Update the contents
				// Should trigger an automatic reload
				core.set_note_text(new_title, text)
			}

			// Create button on suggested notes
			note.create = function() { 
				var title_text = title.innerText

				note.info = core.create_note(title_text)
				note.info.parser = "Markdown"
				reload()
				note.edit()
			}

			// Find similar notes
			note.find_similar = function() { 
				var results = search.lunr_find_similar(note.info.title)

				var results_note = story.create_temporary_note(note.info.title)
				var htmlcode = ""
				var len = results.length

				// Display the self-similarity first and foremost
				var entry = results[0]
				htmlcode += "Self-similarity: " + entry.score

				for (var i = 1; i < len; i++) {
					var entry = results[i]
					var tags = search.lunr_auto_tags(entry.title)

					htmlcode += "<div class=\"search_result\"><div>▶ " + note.link(entry.title) + "</div><div>Similarity: " + entry.score + "</div><div>Tags: " + utils.display_tags(tags) + "</div></div>" 
				}

				results_note.set_title("<i>Find similar: " + note.info.title + "</i>")
				results_note.set_body(htmlcode)
				results_note.scroll_to()
			}

			// Export this note in particular
			note.export = function() {
				networking.download(core.export_note(note.info.title), note.info.title + ".jsbit")
			}

			note.archive = function() {
				core.archive_note(note.info.title)
			}

			note.unarchive = function() {
				core.unarchive_note(note.info.title)
			}
		}

		// Reload function 
		// Text notes: 	fetch the text, parse it as markdown and display it
		// App notes: 	fetch the text and run it
		async function reload() {
			log("Reloading [" + note.info.title + "]")

			// Invoke the editor abort handler
			// It will close the editor for us, in case it was open
			// It will also update the title
			note.abort()

			var parsers = {
				"Markdown": markdown_parser,
				"Text": text_parser,
				"App": app_loader,
				"Iframe": iframe_loader
			}

			// Missing parser security check
			var target_parser = note.info.parser

			if (target_parser in parsers === false) {
				alert(locale.parser_missing + target_parser)
				target_parser = "Text" // Fall back to plaintext parser
			}

			// Execute the parser
			parsers[target_parser]()

			// Scroll to the note at last
			scroll_to()

			
			// And below are the parser functions
			// =======================================================
			function markdown_parser() {
				if (note.info.archived) {
					set_date( utils.format_time(note.info.modified) + "; Archived")
				} else {
					set_date( utils.format_time(note.info.modified) )
				}

				set_body( markdown.parse(note.info.text, note.info.title) )
			}

			function text_parser() {
				if (note.info.archived) {
					set_date( utils.format_time(note.info.modified) + "; Archived")
				} else {
					set_date( utils.format_time(note.info.modified) )
				}
				
				set_body( note.info.text )
			}

			function app_loader() {
				set_date("") // Apps don't show a date by default
				set_body("")

				// On notes with code disable editor wrap by default
				disable_wrap()

				// Clear any previous setInterval() or setTimeout()
				timer_cleanup()

				// Tracking setInterval() and setTimeout() wrappers
				function setIntervalWrapper() {
					note.held_intervals.push( setInterval.apply(window, arguments) )
				}

				function setTimeoutWrapper() {
					note.held_timeouts.push( setTimeout.apply(window, arguments) )
				}

				//
				// App main function
				//
				// Function is constructed from:
				// - note.info.text
				//
				// Using apply() will not work to pass arguments
				// Not without naming them first, anyway
				//
				// List of arguments:
				// - setInterval() 			OVERRIDE
				// - setTimeout()			OVERRIDE
				// - note object
				//
				var run = new AsyncFunction("setInterval",
											"setTimeout",
											"note", note.info.text)

				run(setIntervalWrapper, setTimeoutWrapper, note)
			}

			function iframe_loader() {
				set_date("") // No way of knowing date on iframe contents

				// Do some magic to get the content color right
				// Very useful when including plaintext
				set_body(`<iframe src="${note.info.text}" onload="event.target.contentDocument.body.style.color = window.getComputedStyle(window.document.body).color"></iframe>`)
			}
			// =======================================================
		}

		// We must track every setInterval() and setTimeout() and clear them when note is closed or reloaded
		// If we don't do this, we will end up with a storm of orphaned timer handlers firing on the profiler chart
		function timer_cleanup() {
			for (var interval_id of note.held_intervals) clearInterval(interval_id)
			for (var timeout_id of note.held_timeouts) clearTimeout(timeout_id)

			note.held_intervals = []
			note.held_timeouts = []
		}
	}

	// ==============================================================================
}

ias.story = function() {
	//
	// IAS GUI; story
	//
	// ==============================================================================

	//
	// Story keeps track of what is open right now
	//

	//
	// List of APIs:
	// - open_note()
	// - create_new_note()
	// - create_temporary_note()
	// - suggest_note()
	// - ensure_entry()					INTERNAL
	// - remove_instance()				INTERNAL
	// - spawn_box()					INTERNAL
	// - alert()						INTERNAL
	// - alert_all_notes()				INTERNAL
	// - handle_anchor_change()			URL ANCHOR CHANGE HANDLER
	//

	// Alias
	var story = this

	//
	// This is where we keep our open notes
	// The structure is as follows:
	// { 
	// 	"minicon": 	[ {instance}, {instance}, ... ],
	// 	"IAS": 		[ {instance} ]
	// }
	//
	var entries = this.entries = {}

	// Open a note within the story river
	this.open_note = function(title, after = null) {
		// We do not respect notes with empty title
		if (title === "") {
			log("Can't open a note that has no title.")
			return
		}

		// SINGLE-INSTANCE LIMITER
		// Comment it out to allow multiple instances
		//
		// It works like that:
		// - If a title is present in open entries, scroll to the [0] instance and make it blink
		// - Do not allow to spawn additional instances by returning early
		if (title in entries === true) {
			var note = entries[title][0]
			
			note.scroll_to()
			note.blink()

			return note
		}

		// Check whether the note exists in the storage
		// If no, suggest to create it
		if (core.note_exists(title) === false) {
			story.suggest_note(title, after)
			return
		}

		// If we know this title, ensure an entry of instances
		var instances = story.ensure_entry(title)

		// Initialize the UI + logic
		var info = core.get_note_reference(title)
		var note = story.spawn_box(after)

		// Push the instance
		instances.push(note)

		note.info = info
		note.reload()

		return note
	}

	// Create a brand new note (And start editing it)
	this.create_new_note = function() {
		var title = utils.get_new_title()
		var info = core.create_note(title)

		var note = story.open_note(title)

		note.edit()
	}

	// Ensure that array of instances for a given title is available
	// This is so convoluted because we want to support a windowed interface,
	// where multiple instances of a note can be open at the same time
	this.ensure_entry = function(title) {
		if (title in entries === false) {
			entries[title] = []
		}

		return entries[title]
	}

	// Remove an instance of [note pointer] from under a [title]
	// Invoked by "Close" button handler
	this.remove_instance = function(note, title) {
		var instances = entries[title]
		var idx = instances.indexOf(note)

		if (idx === -1) {
			log("Instance of [", note, "] not found under the title ["+title+"]")
		}

		delete instances[idx]

		// Flatten so we don't have any holes and have a real length
		entries[title] = instances.flat()

		// If we removed the last instance, nuke the title entry altogether
		if (entries[title].length === 0) {
			delete entries[title]
		}
	}

	// Create a temporary note not backed by the note storage
	this.create_temporary_note = function(after = null) {
		var note = story.spawn_box(after)

		note.toolbar.display_temporary_toolbar()
		note.set_title("<i>Temporary note</i>")
		note.set_date(utils.format_time( Date.now() ))

		return note
	}

	// Suggest to create a note
	this.suggest_note = function(title, after) {
		var note = story.spawn_box(after)

		note.toolbar.display_suggestion_toolbar()

		note.set_title(title.italics())
		note.set_date(utils.format_time( Date.now() ))
		note.set_body(locale.note_missing)

		note.scroll_to()
	}

	// Spawn a box inside the story, then define a note on it
	// Empty, but with all the APIs ready to operate
	this.spawn_box = function(after = null) {
		var note = {} // <--- Important line: the object created here will follow you throughout the rest of the code

		note.dom = {}
		note.dom.box = document.createElement("div")
		note.dom.box.classList.add("box")

		// If no "after" specified, simply insert the note as a new child in the <content>
		// Otherwise perform adjacent insertion to the target element
		if (after === null) {
			var story_river = q_sel("body content")
			story_river.appendChild(note.dom.box)
		} else {
			if (after in entries) {
				var previous_note = entries[after][0]
				previous_note.dom.box.insertAdjacentElement("afterend", note.dom.box)
			} else {
				log("Tried to insert a note after ["+after+"] but was unable to find it within the story!")
				var story_river = q_sel("body content")
				story_river.appendChild(note.dom.box)
			}
		}
		
		// Install the APIs and the HTML structure
		cardnote.define_note(note)

		return note
	}

	// Alert the story that a note changed
	this.alert = function(alert, cause) {
		if (cause in entries === false) {
			return
		}

		var instances = entries[cause]

		// On alterations, reload every instance of the note
		if (alert === "note_altered") {
			for (var note of instances) {
				note.reload()
			}
		}

		// On renames, remove the stale title, insert the new title, and update the title on every instance
		if (alert === "note_renamed") {
			var new_title = instances[0].info.title

			delete entries[cause]
			entries[new_title] = instances

			for (var note of instances) {
				note.set_title(new_title)
			}
		}

		// On deletions, close every instance of the note
		if (alert === "note_deleted") {
			for (var note of instances) {
				note.close()
			}

			delete entries[cause]
		}
	}

	// Alert all notes within the story
	// If entries[cause] exists, run the edited/renamed/deleted checks
	// Then, for every open note, call a function note[alert]() if available
	this.alert_all_notes = function(alert, cause) {
		for (var title in entries) {
			var instances = entries[title]

			for (var note of instances) {
				if (alert in note.alerts) {
					note.alerts[alert](cause)
				}
			}
		}
	}

	this.handle_anchor_change = function() {
		var target_note = decodeURI(location.hash.slice(1))
		story.open_note(target_note)
	}

	window.onhashchange = story.handle_anchor_change

	// ==============================================================================
}

ias.navbar = function() {
	//
	// IAS GUI; navbar
	//
	// ==============================================================================

	// Alias
	var navbar = this

	navbar.buttons = {}
	navbar.handlers = {}

	navbar.init = function() {
		navbar.button_area = q_sel(".nav_buttons")
		navbar.menu_area = q_sel(".nav_dropdown")
		navbar.search = q_sel(".nav_search")
		navbar.display_default_navbar()

		navbar.search.placeholder = locale.search_placeholder

		navbar.current_theme = "night.css"
	}

	navbar.clear = function() {
		for (var name in navbar.buttons) {
			navbar.buttons[name].delete_button()
		}
	}

	// Add a navbar button
	navbar.add_button = function(name, text) {
		// 1. Create a button
		navbar.buttons[name] = add("button", navbar.button_area)

		// 2. Set the name
		navbar.buttons[name].innerText = text

		// 3. Button deletion function
		navbar.buttons[name].delete_button = function() {
			navbar.buttons[name].remove()
			delete navbar.buttons[name]
		}

		// 4. Handler function
		navbar.buttons[name].onclick = navbar.handlers[name]
	}

	navbar.display_default_navbar = function() {
		navbar.clear()

		navbar.add_button("create_new_note", 	"New note")
		navbar.add_button("open_settings", 		"Settings")
		navbar.add_button("save", 				"Save")
		navbar.add_button("switch_theme", 		"Theme")
		navbar.add_button("toggle_more", 		"More")
		navbar.add_button("toggle_search", 		"Search")
	}

	navbar.handlers.create_new_note = 	function() { story.create_new_note() }
	navbar.handlers.open_settings = 	function() { story.open_note("Settings") }
	navbar.handlers.save = 				function() { singlefile_saver.save() }
	navbar.handlers.switch_theme = 		function() { navbar.switch_theme() }
	navbar.handlers.toggle_more = 		function() { dropdown.toggle() }
	navbar.handlers.toggle_search = 	function() { story.open_note("Search") }

	// Save warning:
	// - Highlight the save button to warn that you have pending changes
	// - Ask for confirmation if you want to close the tab
	navbar.post_save_warning = function() { 
		navbar.buttons.save.classList.add("alert")
		//window.onbeforeunload = function() { return true }
	}

	navbar.clear_save_warning = function() {
		navbar.buttons.save.classList.remove("alert")
		//window.onbeforeunload = undefined
	}

	// Storage alerts handler
	navbar.alert = function(alert, cause) {
		// Activate the "unsaved changes" warning light
		navbar.post_save_warning()
	}

	// Theme switching
	navbar.switch_theme = function() {
		if (navbar.current_theme === "night.css") {
			navbar.current_theme = "day.css"
		} else {
			navbar.current_theme = "night.css"
		}

		utils.apply_css(navbar.current_theme)
	}

	// ==============================================================================
}

ias.dropdown = function() {
	//
	// IAS GUI; Dropdown navigation menu
	//
	// ==============================================================================
	
	// Dropdown menu is the menu unveiled by clicking "more" button in the navbar
	//

	// Alias
	var dropdown = this
	var open = false
	var elem

	dropdown.init = function() {
		elem = q_sel(".nav_dropdown")
	}

	dropdown.toggle = function() {
		open = elem.classList.contains("open")

		if (open === false) {
			elem.classList.add("open")
			open = true

			dropdown.update()
		} else {
			elem.classList.remove("open")
			open = false
		}
	}

	dropdown.alert = function(alert, cause) {
		if (open) {
			dropdown.update()
		}
	}

	dropdown.update = function() {
		elem.innerHTML = ""

		elem.innerHTML += dropdown.get_recent_notes()
		elem.innerHTML += dropdown.get_apps()
	}

	dropdown.get_recent_notes = function() {
		var htmlcode = "<h1>Recent notes</h1><hr>"

		var titles = core.get_recent_titles(20)
		var count = titles.length

		for (var i = 0; i < count; i++) {
			htmlcode += dropdown.make_link(titles[i])
		}

		return htmlcode
	}
	
	dropdown.get_apps = function() {
		var htmlcode = "<h1>Apps</h1><hr>"

		var titles = core.get_notes_with_field("parser", "App")
		var count = titles.length

		for (var i = 0; i < count; i++) {
			htmlcode += dropdown.make_link(titles[i])
		}

		return htmlcode
	}

	dropdown.make_link = function(title) {
		return `<a class="internal auto" href="#${title}" onclick="story.open_note('${title}'); return false;">${title}</a><br>`
	}



	// ==============================================================================
}

ias.networking = function() {
	//
	// IAS networking
	//
	// ==============================================================================

	// Download some data as a file
	this.download = function(data, name) {
		var type = "text/html";
		var blob = new Blob([data], {'type': type});
		var url = URL.createObjectURL(blob);

		var anchor = add("a")

		anchor.href = url
		anchor.download = name

		anchor.click()
		anchor.remove()
	}

	// Upload some data using PUT
	this.put = async function(data, address) {
		var payload = {method: "PUT", body: data}

		try {
			var response = await fetch(address, payload)
		} catch (err) {
			error(locale.network_error)
			return null
		}

		if (response.status === 200 || response.status === 204) {
			var text_response = await response.text()
			return text_response
		} else {
		    error(locale.server_error + "<hr>" + locale.error_code + response.status + "<br>" + locale.address + address)
		    return null
		}
	}

	// Download some data using GET
	// Available types:
	//		text 		Just give the text
	// 		json 		Parse as JSON while skipping the string conversion step
	// 		blob 		Do not parse or attempt to read as string, just give the data. Appears to be broken on mobile chromium.
	//
	// Chromium will fail quietly on very large JSON
	// There's also a way to make it fail loudly:
	// - Download as a blob
	// - Construct a blob URL
	// - Give blob URL to Fetch
	// - Attempt to call response.json()
	//
	// It will crash.
	this.get = function(address, callback_ready, type = "text") {
		var xhr = new XMLHttpRequest();

		xhr.onload = async function() {
			callback_ready(xhr.response)
		}

		xhr.onprogress = function(event) {
			show_status("Downloading [" + address + "]: <br><div class=progress><div class=bar style='width: " + (event.loaded / event.total * 100) + "%;'></div>" + Math.round(event.loaded / 1024) + "KB</div>")
		}

		xhr.onerror = function(event) {
			error(locale.network_error)
		}

		xhr.open('GET', address, true);
		//xhr.overrideMimeType("application/json");
		xhr.responseType = type
		xhr.send(null);
	}
	// ==============================================================================
}

ias.singlefile_saver = function() {
	//
	// IAS saving code
	//
	// ==============================================================================

	// Save as a single HTML file
	// Two endpoints supported:
	// - Browser download
	// - PUT request to server
	//
	// If IAS was loaded via HTTP/HTTPS, save() will automatically switch to PUT.
	// 		Correction: no, it will not, not at this time.
	//

	//
	// List of APIs:
	// - save()
	// - make_banner(text) 				INTERNAL
	// - save_component(name)			INTERNAL
	// - save_all_components()			INTERNAL
	// - save_notes()					INTERNAL
	// - build_file_text()				INTERNAL
	//

	this.make_banner = function(text) {
		return "//\n// " + text + "\n//\n"
	}

	var js_open = "<script>\n\"use strict\";\n\n"
	var js_close = "</" + "script>\n" 

	this.html_template_start = `<!DOCTYPE html>\n<!-- IAS -->\n<!-- JUMP TO BOTTOM OF THE FILE TO FIND THE ENTRY POINT -->\n<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>IAS</title><link rel="stylesheet" href="night.css"><link rel="stylesheet" href="tags.css"></head><body><nav><div class="nav_topbar"><div class="nav_buttons"></div><input type="text" class="nav_search"></div><div class="nav_dropdown"></div></nav><div class="status_area"></div><content><noscript><div class="box"><p>Can't work without JavaScript, unfortunately.</p></div></noscript></content>\n${"<"}script src="lunr.js" type="text/javascript">${"</"}script>\n${js_open}// Source object\n// Stores the source code of the API Servers / components\n// bootloader.init() will initialize them:\n// - ias.core -> window.core\n// - ias.story -> window.story\n// - ias.locale -> window.locale\n// - etc...\n//\n// Only after initialization can you use them!\n//\nvar ias = {}\n${js_close}\n`
	this.html_template_end = `</body></html>`
	this.entry_point_template = `${js_open}${this.make_banner("IAS entry point")}var bootloader = new ias.bootloader()\nbootloader.init()\n${js_close}`


	this.save_component = function(name) {
		return "ias." + name + " = " + ias[name].toString() + "\n\n"
	}

	this.save_all_components = function() {
		var result = ""

		for (var component in ias) {
			result += this.save_component(component)
		}

		return result
	}

	this.save_notes = function() {
		return "window.ias_cold_storage = " + core.cold_storage_snapshot() + "\n\n"
	}

	this.build_file_text = function() {
		var result = ""

		result += js_open + this.save_all_components() + js_close

		result += js_open
		result += this.make_banner("IAS cold storage")
		result += this.save_notes()
		result += js_close

		return this.html_template_start + result + this.entry_point_template + this.html_template_end
	}

	// Save this copy of IAS as a file
	this.save = async function() {
		var protocol = location.protocol
		var pathname = location.pathname

		// For HTTP or HTTPS attempt to save via PUT request
		// Otherwise download a copy to the user's machine
		if (protocol === "http:" || protocol === "https:") {
			var result = await networking.put(this.build_file_text(), pathname)

			if (result === false) {
				error(locale.saving_error)
				return
			}
		} else {
			alert("Warning! External dependencies.\n\nFollowing files are not integrated into the unified HTML at this time:\n - night.css\n - day.css\n - lunr.js\n\nYou'll need to download them separately and place them next to the .html file.")
			networking.download(this.build_file_text(), "ias.html")
		}

		success(locale.saving_ok)
		navbar.clear_save_warning()
	}
	// ==============================================================================
}

ias.search = function() {
	//
	// IAS search
	//
	// ==============================================================================
	
	// Alias
	var search = this

	// Naive full text search
	// Case-insensitive
	search.search_text = function(pattern, ignore_archived = true) {
		var matches = []

		core.for_each_note( function(note) {
			if (ignore_archived && note.archived)
				return

			if (note.text.toLowerCase().includes(pattern))
				matches.push(note.title)
		} )

		return matches
	}

	search.lunr_search_text = function(text, ignore_archived = true) {
		var lunr_results = search.lunr.search(text)
		var matches = []
		var len = lunr_results.length

		for (var i = 0; i < len; i++) {
			var id = lunr_results[i].ref
			var note = search.idx._documents[id].note

			if (ignore_archived && note.archived)
				continue

			matches.push(note.title)
		}

		return matches
	}

	// Calculate inverse document frequency for a term if lunr hidden fields are exposed
	search.lunr_idf = function(term) {
		//var term = search.lunr.pipeline.runString(token)

		// Shoddy lunr IDF that takes multiple fields into account and uses some math on top
		// Prime candidate for replacement with a classic version
		return lunr.idf(search.lunr.invertedIndex[term], search.idx.documentCount)
	}

	// Attempt to automatically tag a document
	// Returns 10 top terms
	search.lunr_auto_tags = function(title, count = 10) {
		var id = search.idx_find_note_id(title)
		var tf = search.idx.fieldTermFrequencies[id]

		var distinct_tems = 0
		var list = {}

		for (var term in tf) {
			// Skip the empty string term
			// It can usually appear on:
			// - Notes that contain code
			// - Notes that contain markdown
			//
			// It appears as a result of trimmer destroying tokens like "==", ">=", "||", "#", ...
			// We can't just return null from trimmer, it has to be a string
			if (term === "") continue

			var score = tf[term] * search.lunr_idf(term)
			list[term] = score
			distinct_tems++
		}

		var max_tags = Math.min(count, distinct_tems)
		var top = []

		for (var i = 0; i < max_tags; i++) {
			var max_value = 0.0
			var max_term

			for (var term in list) {
				var value = list[term]

				if (value > max_value) {
					max_value = value
					max_term = term
				}
			}

			top.push(max_term)
			delete list[max_term]
		}

		return top
	}

	// Attempt to find documents with a similar document-space vector
	search.lunr_find_similar = function(title) {
		var id = search.idx_find_note_id(title)
		var doc = search.lunr.fieldVectors[id]

		if (doc === undefined) {
			log("Document not found")
			return null
		}

		// Two arrays
		// One keeps scores, the other IDs
		var score_list = []
		var id_list = []

		// Perform a vector dot product with every other document
		for (var other_id in search.lunr.fieldVectors) {
			// Skip self
			if (other_id === id) continue

			var other_doc = search.lunr.fieldVectors[other_id]

			score_list.push( doc.dot(other_doc) )
			id_list.push( other_id )
		}

		// Declare the top 10 (11 actually) array		
		var len = score_list.length
		var top = []

		// First entry is the self-similarity
		var self_similarity = {score: Math.round(doc.dot(doc)), title: title}
		top.push(self_similarity)

		// Sort through all the results and pick out a top 10
		for (var i = 0; i < 10; i++) {
			var max_value = 0.0
			var max_id = 0

			for (var j = 0; j < len; j++) {
				var value = score_list[j]

				if (value > max_value) {
					max_value = value
					max_id = j
				}
			}

			var entry_id = id_list[max_id]
			var entry = {score: Math.round(score_list[max_id]), title: search.idx_get_note_title(entry_id) }
			score_list[max_id] = 0.0

			top.push( entry )
			
		}

		return top
	}

	// Discover words that were seen nearby
	// - Works well with the built-in indexer
	// - May produce odd results with the native indexer
	//   The results do look correct, but seem to come out of order
	//   I think sorting the inverted index interferes with this function
	search.lunr_discover_nearby = function(word) {
		var term = search.lunr.pipeline.runString(word)

		if (term in search.lunr.invertedIndex === false) {
			return null
		}

		var next = []
		var prev = []

		var count = 5
		var idx = search.lunr.invertedIndex[term]._index

		for (var other_term in search.lunr.invertedIndex) {
			var entry = search.lunr.invertedIndex[other_term]
			var delta = idx - entry._index

			if (delta > 0 && delta <= count) {
				prev[count - delta] = other_term
			} else if (delta < 0 && delta >= -count) {
				next[-delta] = other_term
			}
		}

		log(prev.toString().replaceAll(",", " --> ") + " --> " + term + next.toString().replaceAll(",", " --> "))
	}

	// Discover the most common terms amongst all documents
	// This could come in handy if you ever decide to update or generate a new stopword list
	search.idx_find_most_common_terms = function(number) {
		var terms = Object.keys(search.lunr.invertedIndex)
		var sm = utils.sortedmap(number)

		for (var term of terms) {
			var count = Object.keys( search.lunr.invertedIndex[term]["a"] ).length
			sm.insert(count, term)
		}

		sm.log()
	}

	// Discover the longest terms amongst all documents
	// This is useful for debugging what bloats the index down the most
	search.idx_find_longest_terms = function(number) {
		var terms = Object.keys(search.lunr.invertedIndex)
		var sm = utils.sortedmap(number)

		for (var term of terms) {
			sm.insert(term.length, term)
		}

		sm.log()
	}

	// Autocomplete a term from a substring
	// Returns a cloud of available options
	// This function will benefit greatly if entries in the invertedIndex are sorted by likelihood
	search.idx_autocomplete_term = function(needle) {
		var matches = []

		needle = needle.toLowerCase()

		for (var term in search.idx.invertedIndex) {
			if (term.includes(needle) && term != needle) matches.push(term)
		}

		return matches
	}

	// Ensure that Lunr is ready
	// - If it *is* ready, just exit
	// - If search.idx is missing, call search.init_lunr_from_notes() instead
	// - If search.idx is present, perform a partial reinitialization
	//
	// Creates following objects:
	// - search.lunr 				The main lunr object
	//
	// Depends on the following:
	// - search.idx.invertedIndex			Index that maps terms to document IDs
	// - search.idx.fieldTermFrequencies	Index that maps document IDs to the distinct terms they contain, plus the encounter rate for each term
	// - search.idx.fieldLengths			Index that maps document IDs to their total term count
	// - search.idx._documents				Index that maps document IDs to whatever metadata was provided
	// - search.idx.documentCount			Integer, total document count
	search.ensure_lunr = function() {
		if ("lunr" in search) {
			return
		}

		log("Re-initializing lunr...")

		if ("idx" in search === false) {
			log("No pre-restored/pre-baked indices found! Falling back to generating one from scratch.")
			search.init_lunr_from_notes()
			return
		}

		search.lunr = lunr(function () {
			// Reset the default pipelines
			this.pipeline.reset()
			this.searchPipeline.reset()

			// Minimal pipeline without the stemmer
			// Note: nothing at all added to this.searchPipeline
			this.pipeline.add(
				search.unicode_trimmer,
				search.multilang_stopword_filter
			)

			this.field('a') // Shortest possible field name to try and use less RAM
			this.ref('id') 	// Magic name, can't change

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex
		})

		log("Complete!")
	}

	// Search cold start
	//
	// Creates following objects:
	// - search.idx 				A set of primary and secondary indices, some previously hidden
	// - search.lunr 				The main lunr object
	search.init_lunr_from_notes = function() {
		log("Initializing lunr from scratch...")

		search.lunr = lunr(function () {
			this.pipeline.reset()
			this.searchPipeline.reset()

			// Minimal pipeline without the stemmer
			// Note: nothing at all added to this.searchPipeline
			this.pipeline.add(
				search.unicode_trimmer,
				search.multilang_stopword_filter
			)

			this.field('a') 		// Shortest possible field name to try and use less RAM
			this.ref('id') 			// Magic name, can't change

			var temp_ref = this 	// Temporary alias that's visible from within the core.for_each_note()
			var gid = 0 			// Growing ID

			// Use documentCount to generate IDs
			// Store direct references in _documents
			core.for_each_note(function(note) {
				temp_ref.add({id: gid, a: note.text}, {note: note})
				gid++
			})

			// SHOW ME YOUR GUTS PLEASE
			var idx = (search.idx = {})

			idx.invertedIndex 			= this.invertedIndex
			idx.fieldTermFrequencies 	= this.fieldTermFrequencies
			idx.fieldLengths 			= this.fieldLengths
			idx._documents 				= this._documents
			idx.documentCount 			= this.documentCount
			idx.termIndex 				= this.termIndex
			idx.gid 					= gid
		})
		
		log("Complete!")
	}

	// Delete a single note from the indices without regenerating them completely
	search.idx_delete_note = function(id) {
		var short_id = id.slice(2)

		// Refuse to commit operations that will ruin the index
		if (short_id in search.idx._documents === false) {
			log("No such ID")
			return
		}

		// Mark lunr for reinitialization
		delete search.lunr

		// Delete all records of the note
		var terms = search.idx.fieldTermFrequencies[id]

		for (var term in terms) {
			delete search.idx.invertedIndex[term]["a"][short_id]
		}

		delete search.idx.fieldTermFrequencies[id]
		delete search.idx.fieldLengths[id]
		delete search.idx._documents[short_id]

		search.idx.documentCount--
	}

	// Add a single note into the indices without regenerating them completely
	//
	// Depends on the following:
	// - search.idx.termIndex 				Term insertion counter; _index field of the invertedIndex entries is sampled from this counter
	search.idx_add_note = function(title) {
		// Mark lunr for reinitialization
		delete search.lunr

		var builder_fn = function () {
			this.pipeline.reset()
			this.searchPipeline.reset()

			// Minimal pipeline without the stemmer
			// Note: nothing at all added to this.searchPipeline
			this.pipeline.add(
				search.unicode_trimmer,
				search.multilang_stopword_filter
			)

			this.field('a')
			this.ref('id')

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex

			var note = core.get_note_reference(title)

			this.add({id: search.idx.gid, a: note.text}, {note: note})
			search.idx.gid++

			// Backwards-sync integer variables
			search.idx.documentCount 	= this.documentCount
			search.idx.termIndex 		= this.termIndex
		}

		var builder = new lunr.Builder

		builder_fn.call(builder, builder)

		// [Optional] If you don't want to defer, lunr can be rebuilt right here:
		// search.lunr = builder.build()
	}

	// Iterate through _documents and find the specified title
	// Returns null on failure
	search.idx_find_note_id = function(title) {
		for (var id in search.idx._documents) {
			var doc = search.idx._documents[id]

			if (doc.note.title === title) return ("a/" + id)
		}

		return null
	}

	// Get note title from id
	search.idx_get_note_title = function(id) {
		return search.idx._documents[id.slice(2)].note.title
	}

	// Alert handling
	// Index will be updated in real time to reflect changes in the note storage
	search.alert = function(alert, cause) {
		// Exit if index not initialized; nothing to do, yet!
		if ("idx" in search === false) return
		
		
		// Note creation alerts are not handled because freshly created notes are still empty
		// When a note is first altered is the time to add it

		if (alert === "note_altered") {
			var id = search.idx_find_note_id(cause)

			if (id != null) {
				search.idx_delete_note(id)
			}

			search.idx_add_note(cause)
		}

		if (alert === "note_renamed") {
			// No special handling required
			// We don't store titles in the index
		}

		if (alert === "note_deleted") {
			var id = search.idx_find_note_id(cause)
			search.idx_delete_note(id)
		}
	}

	// This is a lightened version of the lunr stemmer
	// Only steps 1a and 1b remain
	// This matches what is used in the native indexer
	search.partial_stemmer = (function(){
		var step2list = {
		      "ational" : "ate",
		      "tional" : "tion",
		      "enci" : "ence",
		      "anci" : "ance",
		      "izer" : "ize",
		      "bli" : "ble",
		      "alli" : "al",
		      "entli" : "ent",
		      "eli" : "e",
		      "ousli" : "ous",
		      "ization" : "ize",
		      "ation" : "ate",
		      "ator" : "ate",
		      "alism" : "al",
		      "iveness" : "ive",
		      "fulness" : "ful",
		      "ousness" : "ous",
		      "aliti" : "al",
		      "iviti" : "ive",
		      "biliti" : "ble"
		    },

		    step3list = {
		      "icate" : "ic",
		      "ative" : "",
		      "alize" : "al",
		      "iciti" : "ic",
		      "ical" : "ic",
		      "ful" : "",
		      "ness" : ""
		    },

			c = "[^aeiou]",          // consonant
			v = "[aeiouy]",          // vowel
			C = c + "[^aeiouy]*",    // consonant sequence
			V = v + "[aeiou]*",      // vowel sequence

			mgr0 = "^(" + C + ")?" + V + C,						// [C]VC... is m>0
			meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",	// [C]VC[V] is m=1
			mgr1 = "^(" + C + ")?" + V + C + V + C,				// [C]VCVC... is m>1
			mgr2 = "^(" + C + ")?" + V + C + V + C + V + C,		// [C]VCVCVC... is m>2
			s_v = "^(" + C + ")?" + v;							// vowel in stem

		var re_mgr0 = new RegExp(mgr0);
		var re_mgr1 = new RegExp(mgr1);
		var re_mgr2 = new RegExp(mgr2);
		var re_meq1 = new RegExp(meq1);
		var re_s_v = new RegExp(s_v);

		var re_1a = /^(.+?)(ss|i)es$/;
		var re2_1a = /^(.+?)([^s])s$/;
		var re_1b = /^(.+?)eed$/;
		var re2_1b = /^(.+?)(ed|ing)$/;
		var re_1b_2 = /.$/;
		var re2_1b_2 = /(at|bl|iz)$/;
		var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
		var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");

		var re_1c = /^(.+?[^aeiou])y$/;
		var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti)$/;

		var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;

		var re_4 = /^(.+?)(ance|ence|able|ible|ment|iti|ive)$/;


		var porterStemmer = function porterStemmer(w) {
			var stem,
				suffix,
				firstch,
				re,
				re2,
				re3,
				re4;

			if (w.length < 4) { return w; }


			firstch = w.substr(0,1);
			if (firstch == "y") {
			  w = firstch.toUpperCase() + w.substr(1);
			}

			// Step 1a
			re = re_1a
			re2 = re2_1a;

			if (re.test(w)) { w = w.replace(re,"$1$2"); }
			else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }

			// Step 1b
			re = re_1b;
			re2 = re2_1b;
			if (re.test(w)) {
			  var fp = re.exec(w);
			  re = re_mgr0;
			  if (re.test(fp[1])) {
			    re = re_1b_2;
			    w = w.replace(re,"");
			  }
			} else if (re2.test(w)) {
			  var fp = re2.exec(w);
			  stem = fp[1];
			  re2 = re_s_v;
			  if (re2.test(stem)) {
			    w = stem;
			    re2 = re2_1b_2;
			    re3 = re3_1b_2;
			    re4 = re4_1b_2;
			    if (re2.test(w)) { w = w + "e"; }
			    else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
			    else if (re4.test(w)) { w = w + "e"; }
			  }
			}

		    // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)
		    re = re_1c;
		    if (re.test(w)) {
		      var fp = re.exec(w);
		      stem = fp[1];
		      w = stem + "i";
		    }

		    // Step 2
		    re = re_2;
		    if (re.test(w)) {
		      var fp = re.exec(w);
		      stem = fp[1];
		      suffix = fp[2];
		      re = re_mgr0;
		      if (re.test(stem)) {
		        w = stem + step2list[suffix];
		      }
		    }

		    // Step 3
		    re = re_3;
		    if (re.test(w)) {
		      var fp = re.exec(w);
		      stem = fp[1];
		      suffix = fp[2];
		      re = re_mgr0;
		      if (re.test(stem)) {
		        w = stem + step3list[suffix];
		      }
		    }

		    // Step 4
/*		    re = re_4;
			if (re.test(w)) {
				var fp = re.exec(w);
      			stem = fp[1];
      			suffix = fp[2];
      			if (suffix === "iti") {
      				re = re_mgr2;
      			} else {
      				re = re_mgr1;
      			}
      			if (re.test(stem)) {
      				w = stem;
      			}
			}
*/
			// Restore_Y
			re = re_mgr0;
			if (re.test(w)) {
				w = w.replace(/i$/, "y")
			}

			if (firstch == "y") {
			  w = firstch.toLowerCase() + w.substr(1);
			}

			return w;
		};

		return function (token) {
			return token.update(porterStemmer);
		}
	})()

	// Modified Lunr trimmer
	// - Will preserve russian characters
	// - Returns an empty string as a result of trimming "==", ">=", "||", "#" and the like
	search.unicode_trimmer = function (token) {
		var rxp_head = /^[^A-Za-zА-Яа-я0-9ёЁ]+/
		var rxp_tail =  /[^A-Za-zА-Яа-я0-9ёЁ]+$/

		return token.update(function (s) {
			return s.replace(rxp_head, '').replace(rxp_tail, '')
		})
	}

	search.multilang_stopword_filter = lunr.generateStopWordFilter([

		// English
		'a', 'able', 'about', 'across', 'after', 'all', 'almost', 'also', 'am', 'among', 'an', 'and', 'any', 'are', 'as', 'at', 'be', 'because', 'been', 'but', 'by', 'can', 'cannot', 'could', 'dear', 'did', 'do', 'does', 'either', 'else', 'ever', 'every', 'for', 'from', 'get', 'got', 'had', 'has', 'have', 'he', 'her', 'hers', 'him', 'his', 'how', 'however', 'i', 'if', 'in', 'into', 'is', 'it', 'its', 'just', 'least', 'let', 'like', 'likely', 'may', 'me', 'might', 'most', 'must', 'my', 'neither', 'no', 'nor', 'not', 'of', 'off', 'often', 'on', 'only', 'or', 'other', 'our', 'own', 'rather', 'said', 'say', 'says', 'she', 'should', 'since', 'so', 'some', 'than', 'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'this', 'tis', 'to', 'too', 'twas', 'us', 'wants', 'was', 'we', 'were', 'what', 'when', 'where', 'which', 'while', 'who', 'whom', 'why', 'will', 'with', 'would', 'yet', 'you', 'your',

		// Russian
		'а', 'и', 'в', 'к', 'с', 'о', 'на', 'но', 'по', 'ни', 'же', 'от', 'то', 'из', 'ли', 'или', 'что', 'так', 'как', 'зато', 'тоже'

	])

	// ==============================================================================
}

ias.markdown = function() {
	//
	// IAS markdown parser
	//
	// ==============================================================================

	// IAS uses a modified version of snarkdown: 
	// https://github.com/developit/snarkdown
	//
	// The code is baked-in, no external files required
	//

	//
	// List of APIs:
	// - parse(markdown, [originNote, depth, links])
	//

	this.parse = function(md, originNote, depth = 0, links = {}) {
		const TAGS = {
						'_': 	['<i>', '</i>'],
						'__': 	['<b>', '</b>'],
						'*': 	['<b>', '</b>'],
						'**': 	['<i>', '</i>'],
						'___': 	['<b><i>', '</i></b>'],
						'***': 	['<b><i>', '</i></b>'],
						'^': 	['<sup>', '</sup>'],
						'~': 	['<sub>', '</sub>'],
						'~~': 	['<s>', '</s>'],
						// '\n': 	['<br>'],
						' ': 	['<br>'],
						'--': 	['<hr>']
					};

		function outdent(str) {
			return str.replace(RegExp('^'+(str.match(/^(\t| )+/) || '')[0], 'gm'), '');
		}

		function encodeAttr(str) {
			return (str+'').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
		}

		let tokenizer = /((?:^---+|\* \*(?: \*)+)\n)|(?:^``` *(\w*)\n([\s\S]*?)\n```$)|(^(?:([>*+-]|\d+\.)\s+.*\n)+)|(?:!\[([^\]]*?)\]\(([^)]+?)\))|(\[)|(\](?:\(([^)]+?)\))?)|(?:^(#{1,6})\s*(.+)\n)|(?:`([^`].*?)`)|(  \n\n*|\*{1,}|_{1,}|\^{1,}|~{1,})|(<[^>]*>)/gm,
			context = [],
			out = '',
			last = 0,
			chunk, prev, token, inner, t;


		function tag(token) {
			let desc = TAGS[token];
			let end = context[context.length-1] == token;
			if (!desc) return token;
			if (!desc[1]) return desc[0];
			if (end) context.pop();
			else context.push(token);
			return desc[end|0];
		}

		function flush() {
			let str = '';
			while (context.length) str += tag(context[context.length-1]);
			return str;
		}

		// Handling for reference-style links
		md = md.replace(/^\[(.+?)\]:\s*(.+)(\n|$)/gm, (s, name, url) => {
			links[name] = url;
			return '';
		});

		while ( (token=tokenizer.exec(md)) ) {
			prev = md.substring(last, token.index);
			last = tokenizer.lastIndex;
			chunk = token[0];
			if (prev.match(/[^\\](\\\\)*\\$/)) {
				// escaped
			}
			// Code blocks:
			else if (t = token[3]) {
				var language = "";

				// Remove the leading/trailing newline that will likely precede/follow the code within a ``` block
				var code = encodeAttr(t).replace(/^\n+|\n+$/g, '');

				// Set the language if available
				if (token[2]) language = "lang-" + token[2];
				
				chunk = `<code class="${language}">${code}</code>`;
			}
			// > Quotes, -* lists:
			else if (t = token[5]) {
				// Ordered list handling
				if (t.match(/\./)) {
					token[4] = token[4].replace(/^\d+/gm, '');
				}

				// Outdent the current level
				// Input:
				// - List Entry 1
				// - - List Entry 2
				// - List Entry 3
				//
				// Output:
				// List Entry 1
				// - List Entry 2
				// List Entry 3
				//
				inner = outdent(token[4].replace(/^\s*[>*+.-]/gm, ''))

				// Recursively parse any sublevels or any additional formatting at current level
				inner = this.parse(inner, originNote, depth + 1, links);
				
				// Sublevel hackfix 1/2
				// We used to get strings like 	"\nList Entry 1<ul>..."
				// But now it's 				"List Entry 1\n<ul>..."
				// Breaking in this place is unacceptable
				// Remove the \n
				inner = inner.replace(/\n<([uo]l)>/gm, "<$1>");
				
				// Decide between a blockquote or a list
				if (t == '>') {
					t = 'blockquote';
				} else {
					t = t.match(/\./) ? 'ol' : 'ul';

					// This will wrap every \n separated section (aka row) into <li>...</li>
					inner = inner.replace(/^(.*)(\n|$)/gm, '<li>$1</li>');
				}

				chunk = '<'+t+'>' + inner + '</'+t+'>';

				// Sublevel hackfix 2/2
				// If we just finished parsing a sublevel, append an \n
				// Avoid adding it at the root level to preserve reproducible spacing
				if (depth > 0) chunk += "\n";
			}
			// Images:
			else if (token[7]) {
				chunk = `<img src="${encodeAttr(token[7])}" alt="${encodeAttr(token[6])}">`;
			}
			// Links:
			else if (token[9]) {
				var onclick_attr = ""
				var class_attr = ""

				// Try to extract explicit URL / reference URL
				var url = token[10] || links[prev];

				// Try to make an internal link if no URL specified
				if (!url) {
					url = "#" + prev;
					class_attr = `class="internal"`
					onclick_attr = `onclick="story.open_note('${prev}', '${originNote}'); return false;"`
				}

				out = out.replace('<a>', `<a ${class_attr} href="${encodeAttr(url)}" ${onclick_attr}>`);
				chunk = flush() + '</a>';

				// Handle [](...) nicely
				if (prev === "" && chunk === "</a>") {
					prev = url
				}
			}
			else if (token[8]) {
				chunk = '<a>';
			}
			// Headings:
			else if (token[11]) {
				t = 'h' + token[11].length;
				chunk = '<'+t+'>' + this.parse(token[12], originNote, depth + 1, links) + '</'+t+'>';
			}
			// `code`:
			else if (token[13]) {
				chunk = `<code class="inline">${encodeAttr(token[13])}</code>`;
			}
			// Inline formatting: *em*, **strong** & friends
			else if (token[14] || token[1]) {
				chunk = tag(token[14] || '--');
			}
			out += prev;
			out += chunk;
		}

		return (out + md.substring(last) + flush()).replace(/^\n+|\n+$/g, '');
	}

	// ==============================================================================
}

</script>
<script>
"use strict";

//
// IAS cold storage
//
window.ias_cold_storage = [{
title:`minicon`,
text:`
var q_sel = note.q_sel // Alias

var con_htmlcode =
\`
<code id="interactive_console_display" class="long glows blinker"></code>
<textarea id="interactive_console_input"></textarea>
\`

note.set_body(con_htmlcode)

var display = q_sel("#interactive_console_display")
var input = q_sel("#interactive_console_input")

input.style.height = "1.2em"
input.style.width = "100%"
input.style.padding = "0px"
input.style.border = "none"
input.style.color = "white"
input.style.backgroundColor = "#333333"
input.style.overflow = "auto"
input.oninput = input_keyhit

display.style.maxHeight = "15em"
display.innerText += ">"

start_blinker(display)

function input_keyhit() {
	if (input.value.slice(-1) === "\\n") {
		var command = input.value.slice(0, -1)
		input.value = ""

		display.innerText += command + "\\n"

		try {
			display.innerText += Function("return " + command).apply() + "\\n"
		} catch(exception) {
			display.innerText += exception + "\\n"
		}
		
		display.innerText += ">"

		// Scroll to bottom
		display.scrollTo({top: display.scrollHeight, behavior: "smooth"})
	}
}

function start_blinker(console) {
	console.blinker_func = function () {
		console.classList.toggle("blinker")
	}
	
	setInterval(console.blinker_func, 250)
}`,
created:1609225937327,
modified:1609225937327,
parser:`App`
},
{
title:`Import notes`,
text:`
var imported = 0
var updated = 0

var drop_area = add("div", note.dom.body)

drop_area.classList.add("drag_and_drop_area")
drop_area.innerHTML = "Drop here..."

var file_tip = add("div", note.dom.body)
file_tip.innerText = "Or pick files if you're on mobile: "

var file_input = add("input", file_tip)
file_input.type = "file"

window.ondragenter = function() {
	event.preventDefault()
	drop_area.classList.add("attenting")
}

window.ondragexit = function() {
	event.preventDefault()
	drop_area.classList.remove("attenting")
}

window.ondragover = function() {
	event.preventDefault()
}

drop_area.ondragenter = function() {
	event.preventDefault()
	drop_area.classList.add("ready")
}

drop_area.ondragexit = function() {
	event.preventDefault()
	drop_area.classList.remove("ready")
}

drop_area.ondragover = function() {
	event.preventDefault()
}

drop_area.ondrop = function() {
	event.preventDefault()
	drop_area.classList.remove("attenting")
	drop_area.classList.remove("ready")

	handle_files(event.dataTransfer.files)
}

file_input.oninput = function() {
	event.preventDefault()
	drop_area.classList.remove("attenting")

	handle_files(file_input.files)
	file_input.value = ""
}

// Takes a FileList
function handle_files(files) {
	imported = 0
	updated = 0

	for (var file of files) {
		import_file(file)
	}
}

async function import_file(file) {
	var text = await file.text()

	// A bit of a security nightmare, this
	var obj_fn = new Function("return " + text)
	var obj = obj_fn()

	// Complain if the object is not an object
	if (typeof(obj) !== "object") {
		alert("Import: file [" + file.name + "] did not evaluate into an object.")
	}

	// Array check
	if (Array.isArray(obj)) {
		for (var note of obj) {
			import_note(note)
		}
	} else {
		import_note(obj)
	}
}

function import_note(imported_note) {
	var title = imported_note.title

	if ( core.note_exists(title) ) {
		var note = core.get_note_reference(title)
		var proceed = confirm("Note ["+title+"] already exists.\\nExisting timestamp: "+note.modified+"\\nImported timestamp: "+imported_note.modified+"\\n\\nReplace existing?")

		if (proceed === false) {
			return
		}

		updated++
	} else {
		var note = core.create_note(title)
		imported++
	}

	// Copy the fields
	for (var field of Object.keys(imported_note)) {
		note[field] = imported_note[field]
	}

	// Switch to the Text parser if no parser was set
	if ("parser" in note === false) {
		note.parser = "Text"
	}

	// Convert YYYYMMDDHHMMSSmmm timestamps into classic Unix timestamps
	if (typeof(note.created) === "string") note.created = utils.parse_note_timestamp(note.created)
	if (typeof(note.modified) === "string") note.modified = utils.parse_note_timestamp(note.modified)

	success("Imported " + imported + " notes<br>Updated " + updated + " notes")
}`,
created:1612277030569,
modified:1612277030569,
parser:`App`
},
{
title:`Markdown guide`,
text:`IAS uses a modified version of the Snarkdown Markdown parser. Below is a brief guide on the available syntax.

Click "Edit" to see the source code.

# Text formatting
---
Three font modes are available:
*Bold*
**Italics**
***Bold + Italics*** 

Strike-through mode is available:
~~Example~~
~~*Example*~~
__~~Example~~__

# Code blocks
---
Blocks of code can be made with a triple backtick:

\`\`\`
<script>
	console.log("Hello World!")
</${'script'}>
\`\`\`

There's also \`inline code blocks\` made using a single backtick.

# Links
---
A total of 4 types of link syntax are available:

Internal link: [Welcome]
External link: [DuckDuckGo](https://ddg.gg/)
External link, no title: [](https://ddg.gg/)
Reference-style link: [Reference 1]

[Reference 1]: https://arxiv.org

# Lists
---
- Lists are supported
- - With sublevels
- Mix \`-\`, \`*\` and \`+\` freely

# Tables
---
Snarkdown never supported tables, but you can use HTML!

<table>
	<tr>
		<th></th>
		<th>0</th>
		<th>1</th>
		<th>2</th>
		<th>3</th>
	</tr>
	<tr>
		<td>0</td>
		<td>x</td>
		<td>6.7</td>
		<td>31.3</td>
		<td>31.3</td>
	</tr>
	<tr>
		<td>1</td>
		<td>6.7</td>
		<td>x</td>
		<td>31.0</td>
		<td>31.0</td>
	</tr>
	<tr>
		<td>2</td>
		<td>31.3</td>
		<td>31.0</td>
		<td>x</td>
		<td>6.8</td>
	</tr>
	<tr>
		<td>3</td>
		<td>31.3</td>
		<td>31.0</td>
		<td>6.8</td>
		<td>x</td>
	</tr>
</table>

# Images
---
Images can be added using \`![Alt text](URL)\` or via an HTML tag.`,
created:1617529440466,
modified:1617532884260,
parser:`Markdown`
},
{
title:`Programming guide`,
text:`IAS features two application layers:
1. API Servers
2. Userspace Apps

API Servers are stored as raw JavaScript code, and Userspace Apps are stored within notes.

# API Servers
---
Open your browser console and execute \`ias.core.toString()\`

This will print the entire code of the "core" API Server, the one responsible for storing and processing notes. You will notice that the code is wrapped into a function:

\`\`\`
function() {
	// ...
	// ...
	// ...

	this.API_aaa = function() { ... }
	this.API_bbb = function() { ... }
}
\`\`\`

If you are familiar with JavaScript, you will instantly recognize this as the old-school way to create custom types/classes.

A restart is required after editing the code of an API Server.

Take a look at the code of "ias.bootloader" API Server to see how the boot process unfolds.

# Userspace Apps
---
Userspace Apps are stored as notes, and thus to see the code of one of the apps you need to take a different approach: \`core.get_note_text("minicon")\`

This should print the string containing the code of the embedded interactive console app. It is stored as a string, so you will notice some escaped characters.

You will see that it's not wrapped into any functions/objects and is more or less written as your usual JavaScript.

Userspace Apps are executed using a Function() constructor. It provides a degree of encapsulation -- you can declare variables and functions inside, and they will not spill over into the outside world.

Here's the gist of it:

\`\`\`
var run = Function("alert('Hello world!')")
run()
\`\`\`

Every app has access to a \`note\` variable which provides the app with a way to control its note. Here are some of the APIs:

\`\`\`
set_body(text)				Set the body
set_title(text)				Set the title
set_date(text)				Set the date
reload()				Reload the note
scroll_to()				Scroll to the note
...					...
\`\`\`

To turn a note into an app, set its parser to "JavaScript / App" in the editor.

Here's a very simple example app:

\`\`\`
note.set_body("Hello from JavaScript!")
\`\`\`

Apps can freely use any of the API servers available. Let's use the markdown API server to parse some markdown:

\`\`\`
var html = markdown.parse("__Hello world!__\\n---\\nMarkdown parser")
note.set_body(html)
\`\`\`

Try it!`,
created:1609225934547,
modified:1618655797948,
parser:`Markdown`
},
{
title:`IAS`,
text:`Hello!

Information Assistance System, or IAS for short, is a system for data storage and organization.

A fusion of a note-taking application, recommender system and a JavaScript scratchpad. A brain extension free from the cloud.

I hope it can find a place in your heart and in your self-hosted infrastructure.`,
created:1614267744062,
modified:1614267744062,
parser:`Markdown`
},
{
title:`Notes of the Day`,
text:`// Initial update
update_notd()

// Install alert handlers
note.alerts.note_created = function() { update_notd() }
note.alerts.note_altered = function() { update_notd() }
note.alerts.note_renamed = function() { update_notd() }
note.alerts.note_deleted = function() { update_notd() }

// Trigger an update every 12 hours
setInterval(update_notd, 1000 * 60 * 60 * 12)

function update_notd() {
	// Ensure that lunr is ready so that we can do automatic tagging
	search.ensure_lunr()

	var head = "Here are some notes that may pick your interest:"
	var tail = "<hr>" +	note.link("System status") + " / " + 
					note.link("List of all notes") + " / " + 
					note.link("IAS")

	var html = ""

	html += head
	html += list_random_notes(3)
	html += tail

	note.set_body(html)
}

function list_random_notes(number) {
	// Get an array of titles, excluding archived notes
	var notes = core.find_titles("")

	// Seed the PRNG
	// Epoch time in ms divided by 12 hours, cast to integer
	// This will give new random notes every 12 hours
	utils.seed_prng(Date.now() / 1000 / 60 / 60 / 12 >>> 0)

	var html = "\\n"

	for (var i = 1; i <= number; i++) {
		// Try random indexes until we hit a non-empty slot
		do {
			var idx = Math.floor(notes.length * utils.prng())
		} while (!notes[idx])

		var title = notes[idx]
		var tags = search.lunr_auto_tags(title, 3)

		html += i + ". " + note.link(title) + " " + utils.display_tags(tags) + "\\n"

		// Empty the slot
		delete notes[idx]
	}

	return html
}
`,
created:1611675231500,
modified:1627221956280,
parser:`App`
},
{
title:`List of all notes`,
text:`

// Perform initial update
update_list()

// Install the alert handlers
note.alerts.note_created = function() { update_list() }
note.alerts.note_altered = function() { update_list() }
note.alerts.note_renamed = function() { update_list() }
note.alerts.note_deleted = function() { update_list() }

function update_list() {
	var note_list = core.get_recent_titles(core.get_note_count())
	var html_code = ""

	for (var i = 0; i < note_list.length; i++) {
		html_code += note.link(note_list[i]) + "\\n"
	}

	note.set_body(html_code)
}
`,
created:1609225934547,
modified:1627292414442,
parser:`App`
},
{
title:`Settings`,
text:`// Data
var data = add("div", note.dom.body)
data.innerHTML = "<h3><ruler>Data</ruler></h3>"

var export_btn = add("button", data)
export_btn.innerHTML = "<h3>Export all notes</h3><div>Save a .json file that can later be imported</div>"
export_btn.onclick = export_all_notes

function export_all_notes() {
	if (confirm("Download all notes as .json file?")) {
		networking.download(core.cold_storage_snapshot(), "ias_notes.json")
	}
}

// Warning: do not apend anything to note.dom.body.innerHTML directly
// It will cause button onclick handlers to be destroyed
// Use add() instead
add("br", note.dom.body)

// Service
var maintenance = add("div", note.dom.body)
maintenance.innerHTML = "<h3><ruler>Maintenance</ruler></h3>"

var search_idx_reset_button = add("button", maintenance)
search_idx_reset_button.innerHTML = "<h3>Reset search index</h3><div>Forcibly clear the index in the event of consistency violation</div>"
search_idx_reset_button.onclick = reset_search_idx

function reset_search_idx() {
	delete search["lunr"]
	delete search["idx"]
}

add("br", note.dom.body)`,
created:1619092027364,
modified:1627616595528,
parser:`App`
},
{
title:`Programming guide: alert functions`,
text:`IAS features several _alert functions_ that can be used by [Userspace Apps]. Here's the full list:

\`\`\`
note_altered				Triggered when some note was altered
note_renamed				Triggered when some note was renamed
note_deleted				Triggered when some note was deleted
note_created				Triggered when a note was created
\`\`\`

Here's how an app can hook to an alert function:

\`\`\`
note.alerts.note_deleted = function(cause) { log("Time to update!") }
\`\`\`

Take a look at the \`alert_all_notes()\` of the \`story\` API server to see how alerts are invoked. Try searching the entire source code for calls to that function to find the places that post various alerts.`,
created:1609838210065,
modified:1632583336214,
parser:`Markdown`
},
{
title:`Programming guide: hijacked functions`,
text:`IAS will override some JavaScript functions for you.

Here is an example you can try:

\`\`\`
var func = function() {
	log("Hello")
}

setInterval(func, 1000)
\`\`\`

Ordinarily you would end up with a runaway interval situation. This thing would keep printing "Hello" to the console even after you closed the note. Things would get even worse if you tried to open this note multiple times, spawning a new interval each time and causing a storm of "Hellos" in the console.

Thankfully, there's a way to overcome this: \`setTimeout()\` and \`setInterval()\` are overridden (Or monkey-patched, as some call it) with a version that tracks timeout/interval IDs in \`note.held_timeouts\` and \`note.held_intervals\`. When a note is closed, every held timeout or interval is cleared.

Don't worry — the functions work in exactly the same way they did before, and you can still use the full \`setTimeout(function, time, arg1, arg2, ...)\` syntax, should you need to. 

See the code of \`cardnote\` API server for more details.

`,
created:1632580559636,
modified:1632583351194,
parser:`Markdown`
},
{
title:`Programming guide: search`,
text:`Search supports live deletion and insertion. If a note was altered, it is quickly deleted from the primary index and then re-inserted again. Secondary and tertiary indices are cleared and will have to be regenerated, but the overhead is greatly reduced compared to a cold start.

Apps call \`search.ensure_lunr()\` to ensure that search is up and ready to operate. If the search is ready to operate, it will do nothing. If only the primary index is ready, it will regenerate secondary and tertiary indices. If there's no primary index, it will do a cold start.

Some functions you can play around with:

\`\`\`
search.idx_find_most_common_terms(number)	Find most common terms
search.idx_find_longest_terms(number)		Find longest terms
search.lunr_discover_nearby(word)		Find words that were seen nearby
\`\`\``,
created:1611669194920,
modified:1633572303542,
parser:`Markdown`
},
{
title:`Welcome`,
text:`Half-baked software ahead. _There are bugs._
---
[GitHub](https://github.com/a0346f102085fe9f/IAS/) / [Updates] / [IAS]
`,
created:1611675231500,
modified:1627989359662,
parser:`Markdown`
},
{
title:`Search`,
text:`
if ("lunr" in search) {
	show_search_prompt()
} else {
	show_index_download_prompt()
}

function show_index_download_prompt() {
	note.set_body("<p>The search needs to download one of the indexes to work.</p><p>It can take up to a minute to evaluate an index, depending on your device.</p><p>Click one of the buttons below:</p>")

	var indexes = []

	indexes.push( {title: "Index A 	64.0M 	Full Anonymous directory index.", 								url: "idx/index_a.json"} )
	indexes.push( {title: "Index B 	56.0M 	The 5 largest directories, full of non-pony crap.",	 					url: "idx/index_b.json"} )
	indexes.push( {title: "Index C 	55.8M 	Next 25 directories.",	 										url: "idx/index_c.json"} )
	indexes.push( {title: "Index D 	57.3M 	Next 45 directories.",	 										url: "idx/index_d.json"} )
	indexes.push( {title: "Index E 	59.3M 	Next 65 directories.",	 										url: "idx/index_e.json"} )
	indexes.push( {title: "Index F 	58.3M 	Next 95 directories.",	 										url: "idx/index_f.json"} )
	indexes.push( {title: "Index G 	60.4M 	Next 140 directories.",	 										url: "idx/index_g.json"} )
	indexes.push( {title: "Index H 	59.7M 	Next 195 directories.",	 										url: "idx/index_h.json"} )
	indexes.push( {title: "Index I 	60.0M 	Next 340 directories.",	 										url: "idx/index_i.json"} )
	indexes.push( {title: "Index J 	59.6M 	Next 670 directories.",	 										url: "idx/index_j.json"} )
	indexes.push( {title: "Index K 	38.5M 	Next 1826 directories.",	 										url: "idx/index_k.json"} )
	indexes.push( {title: "Index L 	51.6M 	Stuff that is not present in green.zip dump.",	 						url: "idx/index_l.json"} )
	indexes.push( {title: "Pile		274.8M 	Full poneb.in dump.\\n1/3\\t\\t\\t\\tYears 2009 - 2013.\\n\\t\\t\\t\\tStemmer disabled.\\n\\t\\t\\t\\tHosted on IPFS.", 	url: "https://cloudflare-ipfs.com/ipfs/QmaydmgPzWVMgUYpBqmPXE58P2DtVwdJhdPBQKDCNnhrqB/pile_2009_2013.json"} )
	indexes.push( {title: "Pile		481.8M 	Full poneb.in dump.\\n2/3\\t\\t\\t\\tYears 2014 - 2017.\\n\\t\\t\\t\\tStemmer disabled.\\n\\t\\t\\t\\tHosted on IPFS.", 	url: "https://cloudflare-ipfs.com/ipfs/QmaydmgPzWVMgUYpBqmPXE58P2DtVwdJhdPBQKDCNnhrqB/pile_2014_2017.json"} )
	indexes.push( {title: "Pile		133.1M 	Full poneb.in dump.\\n3/3\\t\\t\\t\\tYears 2018 - 2020.\\n\\t\\t\\t\\tStemmer disabled.\\n\\t\\t\\t\\tHosted on IPFS.", 	url: "https://cloudflare-ipfs.com/ipfs/QmaydmgPzWVMgUYpBqmPXE58P2DtVwdJhdPBQKDCNnhrqB/pile_2018_2020.json"} )
	indexes.push( {title: "Ponepaste  69.4M 	Ponepaste.org backup as of 2021.05.19", 							url: "idx/index_ponepaste.json"} )

	for (var i = 0; i < indexes.length; i++) {
		var index = indexes[i]

		var button = add("button", note.dom.body)
		button.style.textAlign = "start"
		button.innerText = index.title
		button.index_url = index.url
		button.onclick = handle_click

		add("br", note.dom.body)
	}

}

function handle_click(event) {
	download_index(event.target.index_url)
}

async function download_index(url) {

	// Install the search initialization function
	search.init_lunr_from_prebaked = function() {
		log("Lunr prebaked init")

		// Poneb.in and ponepaste.org have different naming conventions
		// We need to handle both
		function link_ponebin(title) {
			var paste_id = (title.slice(title.lastIndexOf("-") + 1)).slice(0, -4)
			var link = "https://poneb.in/" + paste_id

			return "Open at poneb.in: <a href=\\""+link+"\\">"+link+"</a>\\n\\nThe pastes here... they are too hot for GitHub.\\n\\nEven though you see no text, More -> \\"Find similar notes\\" button still functions as intended!"
		}

		function link_ponepaste(title) {
			var paste_id = parseInt(title)
			var link = "https://ponepaste.org/" + paste_id

			return "Open at ponepaste.org: <a href=\\""+link+"\\">"+link+"</a>\\n\\nThe pastes here... they are too hot for GitHub.\\n\\nEven though you see no text, More -> \\"Find similar notes\\" button still functions as intended!"
		}

		var link_fn = 0

		// Decide based on the index filename
		if (url.endsWith("index_ponepaste.json")) {
			link_fn = link_ponepaste
		} else {
			link_fn = link_ponebin
		}

		// All of the stuff should've already been set
		// Except search.idx._documents and gid
		// Manually bitbang some more stuff into existence
		search.idx._documents = {}

		var len = search.idx.documentCount

		for (var i = 0; i < len; i++) {
			var title = search.idx.id_to_filename[i]

			var note = core.create_note(title)
			note.text = link_fn(title)

			search.idx._documents[i] = {note: note}
		}

		search.idx.gid = len

		
		var enable_stemmer = true

		// Very special handling for the Piles
		if (url.includes("pile"))
			enable_stemmer = false


		// Nuke if exists
		delete search.lunr

		search.lunr = lunr(function () {
			// Reset the default pipelines
			this.pipeline.reset()
			this.searchPipeline.reset()

			// Then set them up again, either with or without the stemmer
			if (enable_stemmer) {
				this.pipeline.add(
					lunr.trimmer,
					lunr.stopWordFilter,
					search.partial_stemmer
				)

				this.searchPipeline.add(
					search.partial_stemmer
				)
			} else {
				this.pipeline.add(
					lunr.trimmer,
					lunr.stopWordFilter
				)

				//this.searchPipeline.add()
			}



			// Only one field to index
			// Shortest possible name to use less RAM
			this.field('a')
			this.ref('id')

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex
		})

		log("Complete!")
		log("All OK")
	}


	show_status("Downloading ["+url+"]...")
	var time_dl_start_ms = performance.now()

	networking.get(url, dl_complete, "json")

	function dl_complete(idx) {
		var time_dl_done_ms = performance.now()
		show_status("Download and parsing complete; generating secondary and tertiary indices...")

		search.idx = idx
		search.init_lunr_from_prebaked()

		var time_init_ok_ms = performance.now()

		success("Index installed!<br>" + (time_dl_done_ms - time_dl_start_ms) + "ms to download and parse<br>" + (time_init_ok_ms - time_dl_done_ms) + "ms to initialize lunr")

		show_search_prompt()
	}

}

function show_search_prompt() {
	note.set_body("")

	note.search_field = add("input", note.dom.body)
	note.search_field.placeholder = "Search..."
	note.search_field.type = "text"

	note.search_results_root = add("div", note.dom.body)
	note.search_results_drop = add("div", note.search_results_root)
	note.search_results = add("div", note.search_results_drop)
	note.search_tooltip = add("div", note.search_results_drop)

	note.search_tooltip.innerHTML = "<hr>Prefix words with <kbd>-</kbd> to disallow them, prefix words with <kbd>+</kbd> to make them required. Use <kbd>*</kbd> for unknown letters. Add <kbd>^10</kbd> after the word to multiply the importance by 10, add <kbd>~1</kbd> for fuzzy search with a distance of 1."

	note.search_results_root.style.position = "relative"
	note.search_results_drop.style.position = "absolute"

	note.search_results_drop.classList.add("dropdown", "hide")

	note.search_results_drop.onmouseover = lock_results
	note.search_results_drop.onmouseout = unlock_results
	note.search_field.onmouseover = lock_results
	note.search_field.onmouseout = unlock_results

	note.search_field.onfocus = handle_focus
	note.search_field.oninput = handle_input
	note.search_field.onkeydown = handle_tab

	document.onclick = hide_results
}

var results_locked = 0

function lock_results() { results_locked = 1 }
function unlock_results() { results_locked = 0 }

function show_results() {
	note.search_results_drop.classList.remove("hide")
}

function hide_results() {
	if (results_locked === 0) {
		note.search_results_drop.classList.add("hide")
	}
}

function handle_focus() {
	if (note.search_field.value != "") show_results()
}

var input_timeout = 0
var source_query = ""
var completions = []

function handle_input() {
	clearTimeout(input_timeout)

	source_query = note.search_field.value
	completions = []

	if (source_query === "") {
		unlock_results()
		hide_results()
	} else {
		input_timeout = setTimeout(run_search, 250)
	}
}

function handle_tab(event) {
	if (event.key === "Tab") {
		clearTimeout(input_timeout)
		event.preventDefault()

		var tokens = source_query.split(" ")
		var last = tokens.length - 1

		if (completions.length === 0) {
			completions = search.idx_autocomplete_term(tokens[last])

			// Blink angrily if no autocompletions found
			if (completions.length === 0) {
				blink(note.search_field)
				return
			}

			// Special handling for Shift+Tab first completion
			if (event.shiftKey === true) {
				completions.unshift( completions.pop() )
			}

		} else {
			if (event.shiftKey === false) {
				completions.push( completions.shift() )
			} else {
				completions.unshift( completions.pop() )
			}
		}

		tokens[last] = completions[0]
		note.search_field.value = tokens.join(" ")

		run_search()
	}
}

var entries = []

function run_search() {
	var unsafe_rxp_1 = /[~^+-]$/g // Detect stray +/-/^/~
	var unsafe_rxp_2 = /\\B\\*\\B/g // Detect stray *
	var unsafe_rxp_3 = /:/g // Detect stray :
	var query = note.search_field.value
	var results = note.search_results

	// Abort previous jobs
	note.timer_cleanup()

	var unsafe = unsafe_rxp_1.test(query) || unsafe_rxp_2.test(query) || unsafe_rxp_3.test(query)

	if (unsafe) {
		results.innerHTML = "<p>Refusing incomplete/unsafe query.</p>"
	} else {
		var text_matches = search.lunr_search_text(query)

		results.innerHTML = ""
		entries = []
		show_results()

		function complete_fn() {
			var title_matches = core.find_titles(query)

			lazy_append(title_matches, "📔", results, function() {})

			if (title_matches.length === 0 && text_matches.length === 0) {
				results.innerHTML = "<p>Nothing found...</p>"
			}
		}

		setTimeout( function() { lazy_append(text_matches, "📖", results, complete_fn) } )
	}
}

function add_entry(_title, _tags, _icon, parent) {
	var entry = add("div", parent)
	var icon = add("i", add("span", entry))
	var title = add("div", entry)
	var tags = add("div", entry)

	entry.classList.add("search_result")
	title.classList.add("result_title")
	icon.classList.add("flr")

	title.innerHTML = "▶ " + note.link(_title)
	icon.innerHTML = "<i>" + _icon + "</i>"
	tags.innerHTML = utils.display_tags(_tags)

	entries[_title] = { title: title, tags: tags, icon: icon }
}

// Never touch it again
function lazy_append(titles, icon, parent, complete_fn, depth = 0) {
	if (depth >= titles.length || depth >= 10) return setTimeout( complete_fn )

	var title = titles[depth]
	var tags = search.lunr_auto_tags(title)

	if (title in entries === false) {
		add_entry(title, tags, icon, parent)
	} else {
		entries[title].icon.innerHTML += icon
	}

	// setTimeout without a time argument will just enqueue the job right away
	setTimeout(function() { lazy_append(titles, icon, parent, complete_fn, depth + 1) })
}

`,
created:1610984355543,
modified:1633589396670,
parser:`App`
},
{
title:`Updates`,
text:`> October 7, 2021: [ It Ends in Dust and Disarray ]

Highlights:
 - Markdown ^superscript^ and ~subscript~
 - Distinct style for blockquotes
 - Story multi-instance
 	* Intented for winbox.js UI
 	* Disabled for now

Other:
 - Fixes to markdown lists and links

> September 11, 2021: [ Frozen Points in Time ]

Highlights:
 - Shift+Tab for Autocomplete
	* Use it to go backwards through the list of completions
	* The list wraps around
 - Theme button revamped
	* Added a new Day Theme
	* Based on Solarized Light

Other:
 - Stemmer disabled for the built-in indexer; produces better tags


> August 29, 2021: [ Some Improvements Update ]

Highlights:
 - Substring Autocomplete
	* Switched from <code class="inline">term.startsWith(prefix)</code> to <code class="inline">term.includes(needle)</code>
	* Suggests left hand side completions now, like "batmare" for "mare"
 - Pending Job Abort functionality for search
	* Search will not slow down to a crawl when you jam the <kbd>Tab</kbd> key
	* Less CPU cycles wasted

Other:
 - Some code and style bugfixes


> August 15, 2021: [ Reworked Pile ]

Highlights:
 - New Pile index
	* Generated from full poneb.in dump
	* Three parts grouped by years
	* Works with Chromium
	* Stemmer disabled
		- Use a lot of <kbd>Tab</kbd> instead
	* Hosted on IPFS
	* If self-hosting:
		- Download the files separately: <a href="https://ipfs.io/ipfs/QmaydmgPzWVMgUYpBqmPXE58P2DtVwdJhdPBQKDCNnhrqB/pile_2009_2013.json">first</a>, <a href="https://ipfs.io/ipfs/QmaydmgPzWVMgUYpBqmPXE58P2DtVwdJhdPBQKDCNnhrqB/pile_2014_2017.json">second</a>, <a href="https://ipfs.io/ipfs/QmaydmgPzWVMgUYpBqmPXE58P2DtVwdJhdPBQKDCNnhrqB/pile_2018_2020.json">third</a>
		- Place them in <kbd>idx/</kbd>
		- Edit the Search note with updated paths

<table>
	<tr>
		<th></th>
		<th>Documents</th>
		<th>Size</th>
	</tr>
	<tr>
		<td>Pile 2009 - 2013</td>
		<td>23699</td>
		<td>274.8M</td>
	</tr>
	<tr>
		<td>Pile 2014 - 2017</td>
		<td>29900</td>
		<td>481.8M</td>
	</tr>
	<tr>
		<td>Pile 2018 - 2020</td>
		<td>8153</td>
		<td>133.1M</td>
	</tr>
</table>

> August 5, 2021: [ IAS Rollup Update 2 ]

Highlights:
 - Progressive search
	* First results appear right away
	* Feels way more responsive
	* Makes using search with The Pile somewhat bearable
 - Search Autocomplete
	* Hit <kbd>Tab</kbd> to cycle through autocompletions for the current word
	* Makes finding unlikely tokens, like "assdicktentacle", easy
	* Most likely autocompletions will be suggested first
	* Will flash if no autocompletions found

Other:
 - Search will not re-run the query if you refocus it, now will run queries only on input or <kbd>Tab</kbd> keyhits
 - Export all notes functionality now resides in Settings app
 - Introduced "Notes of the Day" app
 - Introduced "Iframe" parser
 - Removed "Process" parser
 - Some functions you can play around with from the browser console:

<code>search.idx_find_most_common_terms(number)
search.idx_find_longest_terms(number)
search.idx_autocomplete_term(prefix)
</code>


> July 31, 2021: [ Prefix Removal Update ]

Highlights:
 - Index A to K have been regenerated with the author/upload time/dump time info removed
	* Very slight increase in signal to noise ratio
	* Very slight reduction in size
 - Added Index L that was generated from \`green_May_2018.tar\`
	* Deduplicated with pastebin IDs found in \`green.zip\`
	* 40166 duplicate documents discarded
	* 5 empty documents discarded
	* 4768 documents added

<table>
	<tr>
		<th></th>
		<th>Directories</th>
		<th>Documents</th>
		<th>Size then</th>
		<th>Size now</th>
	</tr>
	<tr>
		<td>Index A</td>
		<td>1</td>
		<td>6337</td>
		<td>65.4M</td>
		<td>64.0M</td>
	</tr>
	<tr>
		<td>Index B</td>
		<td>5</td>
		<td>3908</td>
		<td>56.8M</td>
		<td>56.0M</td>
	</tr>
	<tr>
		<td>Index C</td>
		<td>25</td>
		<td>3218</td>
		<td>56.5M</td>
		<td>55.8M</td>
	</tr>
	<tr>
		<td>Index D</td>
		<td>45</td>
		<td>3360</td>
		<td>58.0M</td>
		<td>57.3M</td>
	</tr>
	<tr>
		<td>Index E</td>
		<td>65</td>
		<td>4426</td>
		<td>60.3M</td>
		<td>59.3M</td>
	</tr>
	<tr>
		<td>Index F</td>
		<td>95</td>
		<td>5590</td>
		<td>59.5M</td>
		<td>58.3M</td>
	</tr>
	<tr>
		<td>Index G</td>
		<td>140</td>
		<td>4618</td>
		<td>61.3M</td>
		<td>60.4M</td>
	</tr>
	<tr>
		<td>Index H</td>
		<td>195</td>
		<td>5545</td>
		<td>60.8M</td>
		<td>59.7M</td>
	</tr>
	<tr>
		<td>Index I</td>
		<td>340</td>
		<td>5319</td>
		<td>61.2M</td>
		<td>60.0M</td>
	</tr>
	<tr>
		<td>Index J</td>
		<td>670</td>
		<td>6270</td>
		<td>60.9M</td>
		<td>59.6M</td>
	</tr>
	<tr>
		<td>Index K</td>
		<td>1826</td>
		<td>5493</td>
		<td>39.7M</td>
		<td>38.5M</td>
	</tr>
	<tr>
		<td>Index L</td>
		<td>-</td>
		<td>4768</td>
		<td>-</td>
		<td>51.6M</td>
	</tr>
</table>

> June 30, 2021: [ Ponepaste Backup Update ]

Highlights:
 - Add an index generated from Ponepaste.org backup from 2021.05.19
	* Some titles were broken within the backup, and may link to ponepaste.org/NaN or an incorrect ID
	* This index will get outdated as time goes on

> April 30, 2021: [ The Markdown Update ]

Highlights:
 - Add a built-in Markdown parser
	* Significantly modified version of Snarkdown
	* Tuned to be more plaintext-friendly
 - Add a title search independent of lunr.js
	* Matches by title are given higher priority
	* Queries follow boolean AND logic, with space as a separator
	* Results are ordered by last modification date descending
 - Introduced the concept of archived notes
	* Archived notes are invisible to search
 - Introduced the concept of note parsers
	* Plaintext, Markdown, App, Process
	* Fetch and IFrame parsers to come
	* Logic for remote_url notes deleted
 - Style fixes for mobile devices
	* May require you to go and edit the CSS for a smaller font size

Other:
 - Rewrite in the ias.story API server


> March 7, 2021: [ The Pile Update ]

Highlights:
 - Add a gigantic all-encompassing index, along with the infrastructure required to load it
	* No stemming, all words preserved as-is
	* Weighs 777MB
	* Does not work in chromium-based browsers; either fails silently or crashes <a href="https://github.com/chromium/chromium/blob/cc1cde9919f8eaa2e28e6ed61654a67bbf04c89e/third_party/blink/renderer/platform/wtf/allocator/partition_allocator.h#L32">right here</a>. Digging further, this allocator appears to have a hard limit of 2^31 bytes, <a href="https://github.com/chromium/chromium/blob/cc1cde9919f8eaa2e28e6ed61654a67bbf04c89e/base/allocator/partition_allocator/partition_alloc_constants.h#L259">declared here.</a> Sure enough, there's someone <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=416284">complaining about RAM limits in chromium</a>, although it looks like I may be hitting a different bug here.
	* Stored on IPFS
	* Please consider self-hosting to avoid torturing IPFS gateways:
		- Download <a href="https://github.com/a0346f102085fe9f/IAS/archive/master.zip">IAS</a> and <a href="https://gateway.ipfs.io/ipfs/QmYKnbVVwuCC2MDaxnikgZf4Xk12h6gjQquy6DkhJNa1Lo/the_pile.json">The Pile</a> itself
		- Place <kbd>the_pile.json</kbd> into <kbd>idx/</kbd>
		- Run <kbd>index.html</kbd> in Firefox

Other:
 - Show kilobytes downloaded in the progress bar
 - Parse JSON at download-time using <kbd>xhr.responseType = "json"</kbd>

> February 28, 2021: [ IAS Rollup Update 1 ]

Highlights:
 - There is now a download progress bar
 - Search: expose the <kbd>^</kbd> boost postfix
 - Indexer: stemmer improvements
	* Steps 1abc, 2 and 3 now implemented
	* Fixed some previously undiscovered bugs
	* Fixed "poni" and "technologi"
	* 2% decrease in size
 - Indexer: index format was converted to proper JSON, loaded with JSON.parse()
	* Loads much faster
	* No RAM spikes
	* Allows unicode and stuff
	* 26% increase in size... additional syntax really bloats it
 - Indexer: the <kbd>'</kbd> symbol is allowed now
	* Allows to discern between \`luna\` and \`luna's\`.
	* 1% increase in size

Other:
 - Note fields are now closer to what's in TiddlyWiki, allowing some interchangeability
 - Note importing, both IAS format and TiddlyWiki format
 - Support for <kbd>Tab</kbd> key in the editor
 - Fixes to automatic editor resize
 - Wrap toggle in the editor (Not exposed for now)
 
<table>
	<tr>
		<th></th>
		<th>Directories</th>
		<th>Documents</th>
		<th>Size v1.0</th>
		<th>Size v1.1</th>
	</tr>
	<tr>
		<td>Index A</td>
		<td>1</td>
		<td>6337</td>
		<td>53.3M</td>
		<td>65.4M</td>
	</tr>
	<tr>
		<td>Index B</td>
		<td>5</td>
		<td>3908</td>
		<td>46.2M</td>
		<td>56.8M</td>
	</tr>
	<tr>
		<td>Index C</td>
		<td>25</td>
		<td>3218</td>
		<td>46.1M</td>
		<td>56.5M</td>
	</tr>
	<tr>
		<td>Index D</td>
		<td>45</td>
		<td>3360</td>
		<td>47.4M</td>
		<td>58.0M</td>
	</tr>
	<tr>
		<td>Index E</td>
		<td>65</td>
		<td>4426</td>
		<td>49.1M</td>
		<td>60.3M</td>
	</tr>
	<tr>
		<td>Index F</td>
		<td>95</td>
		<td>5590</td>
		<td>48.5M</td>
		<td>59.5M</td>
	</tr>
	<tr>
		<td>Index G</td>
		<td>140</td>
		<td>4618</td>
		<td>49.9M</td>
		<td>61.3M</td>
	</tr>
	<tr>
		<td>Index H</td>
		<td>195</td>
		<td>5545</td>
		<td>49.3M</td>
		<td>60.8M</td>
	</tr>
	<tr>
		<td>Index I</td>
		<td>340</td>
		<td>5319</td>
		<td>49.7M</td>
		<td>61.2M</td>
	</tr>
	<tr>
		<td>Index J</td>
		<td>670</td>
		<td>6270</td>
		<td>49.3M</td>
		<td>60.9M</td>
	</tr>
	<tr>
		<td>Index K</td>
		<td>1826</td>
		<td>5493</td>
		<td>32.0M</td>
		<td>39.7M</td>
	</tr>
</table>


> January 26, 2021: [ Initial release ]
`,
created:1614426404343,
modified:1633589750460,
parser:`Text`
}]

</script>
<script>
"use strict";

//
// IAS entry point
//
var bootloader = new ias.bootloader()
bootloader.init()
</script>
</body></html>
<!DOCTYPE html><html><head><meta charset="utf-8"><title>IAS</title><link rel="stylesheet" href="style.css"><link rel="stylesheet" href="tags.css"></head><body><nav><div class="nav_topbar"><div class="nav_buttons"></div><input type="text" class="nav_search"></div><div class="nav_dropdown"></div></nav><div class="status_area"></div><content><noscript><div class="box"><p>Can't work without JavaScript, unfortunately.</p></div></noscript></content>
<script src="lunr.js"></script>
<!-- JUMP TO BOTTOM OF THE FILE TO FIND THE ENTRY POINT -->
<script>
"use strict";

// Source object
// Stores the source code of the API Servers / components
// bootloader.init() will initialize them:
// - ias.core -> window.core
// - ias.story -> window.story
// - ias.locale -> window.locale
// - etc...
//
// Only after initialization can you use them!
//
var ias = {}
</script>

<script>
"use strict";

ias.locale = function() {
	//
	// IAS localization strings
	//
	// ==============================================================================
	
	this.date_format = "en-US"
	this.date_options = {year: "numeric", month: "long", day: "numeric", hour: "numeric", minute: "numeric"}

	this.note_missing = "A note with this title does not yet exist. Use the Create button to create it!"
	this.new_note_title = "Note "

	this.search_placeholder = "Search..."

	this.saving_error = "Unable to save!"
	this.saving_ok = "Saved."

	this.network_error = "Networking: network error"
	this.server_error = "Networking: server error"
	this.error_code = "Error code: "
	this.address = "Address: "

	// ==============================================================================
}

ias.core = function() {
	//
	// IAS core
	//
	// ==============================================================================
	
	// The code to load the notes, save the notes, search the notes, etc...
	// 
	// Each note is an object that features a set of fields;
	// Most importantly:
	// - Title
	// - Creation date
	// - Modification date
	// - Body
	//
	// There's also a set of secondary fields:
	// - System Note Flag [Hides the note from the usual search]
	// - List of tags [Just an array of tags]
	// - Remote URL [If the body is stored elsewhere]
	//
	// Really you can add any field you need, but these are reserved
	//
	
	//
	// List of APIs:
	// - note_exists(title)
	// - create_note(title)
	// - delete_note(title)
	// - rename_note(title, new_title)
	// - get_note_reference(title)
	// - get_note_text(title)
	// - for_each_note(callback)
	// - get_oldest_titles(number)
	// - get_recent_titles(number)
	// - get_notes_with_field(field, value)
	// - export_note(title, id)
	// - cold_storage_snapshot()
	// - cold_storage_restore()
	// - float_to_bottom(title)					INTERNAL
	// - update_title_hashmap()					INTERNAL
	// - fire_alert()							INTERNAL
	//
	
	// Async Function Constructor
	// A bit of a hidden feature, but seems to have been supported for a long time
	window.AsyncFunction = Object.getPrototypeOf(async function(){}).constructor
	
	// Note storage
	// WARNING: reveal_pointers() needs to be called again if one of the variables is ever reassigned!
	//
	// notes	[id => note_object] 	always sorted modification_date ASCENDING
	// titles	{note_title => id}		not sorted
	var notes = []
	var titles = {}
	

	// Check whether a note by this title exists
	this.note_exists = function(title) {
		return (title in titles)
	}

	// Create a new note
	this.create_note = function(title) {
		var note = {}
		
		// Check if a note by this title already exists
		if (titles[title] != undefined) {
			log("Tried to create a note ["+title+"] but it already exists!")
			return null
		}
		
		note.title = title
		note.body = ""
		note.creation_date = Date.now()
		note.modification_date = Date.now()
		
		var id = notes.push(note) - 1
		titles[title] = id

		this.fire_alert("note_created", title)
		
		return note
	}

	// Delete the note
	// Will leave holes in the notes array, but that's okay
	// It will be flattened upon saving
	this.delete_note = function(title) {
		var id = titles[title]
		
		delete titles[title]
		delete notes[id]

		this.fire_alert("note_deleted", title)
	}

	// Rename the note
	// Will leave holes in the note array
	this.rename_note = function(title, new_title) {
		var id = titles[title]
		var note = notes[id]

		delete titles[title]

		// Punch holes only if necessary
		if (id < notes.length - 1) {
			delete notes[id]

			id = notes.push(note) - 1
		}

		note.title = new_title
		titles[new_title] = id

		this.fire_alert("note_renamed", title)
	}

	// Get the total note count
	// Doesn't count holes
	this.get_note_count = function() {
		var count = 0

		for (var title in titles) {
			count++
		}

		return count
	}

	// Fetch a reference to the note
	// * Low level function!
	// * Fields may not be populated
	// * DO NOT, NEVER write any fields directly
	// [Potential place to implement a one-deep cache later]
	this.get_note_reference = function(title) {
		var id = titles[title]
		var note = notes[id]

		return note
	}
	
	// Fetch the note text only
	// * Notes with remote URL may need to be fetched over the network
	this.get_note_text = function(title) {
		var note = this.get_note_reference(title)

		if (note.remote_url != undefined) {
			log("Remote fetch from core not supported. Fetch manually.")
			return " --- REMOTE --- "
		}

		return note.body
	}

	// Set the note text only
	// * Will refuse to alter remote notes
	this.set_note_text = function(title, text) {
		var note = this.get_note_reference(title)

		if (note.remote_url != undefined) {
			log("Can't alter a remote note!")
			return
		}

		note.body = text

		this.float_to_bottom(title)
		this.fire_alert("note_altered", title)
	}
	
	// Iterate over each note and call the callback
	// * Supports async functions
	this.for_each_note = function(callback) {
		for (var note of notes) {
			if (note != undefined) callback(note)
		}
	}

	// Returns an array no longer than [number]
	this.get_oldest_titles = function(number) {
		var note_list = []
		var len = notes.length

		for (var j = 0, i = 0; (i < len) && (j < number);) {
			if (i in notes) { // Skip over holes
				note_list.push(notes[i].title)
				j++
			}
			i++
		}

		return note_list
	}

	// Returns an array no longer than [number]
	this.get_recent_titles = function(number) {
		var note_list = []

		for (var j = 0, i = notes.length - 1; (i >= 0) && (j < number);) {
			if (i in notes) { // Skip over holes
				note_list.push(notes[i].title)
				j++
			}
			i--
		}

		return note_list
	}

	// Get notes that contain a certain [field] with certain [value]
	// If [value] is not specified, will count any note that has the field
	this.get_notes_with_field = function(field, value = null) {
		var note_list = []
		var len = notes.length

		for (var i = 0; i < len; i++) {
			if (i in notes) {
				if (field in notes[i]) {
					if (value === null) {
						note_list.push(notes[i].title)
					} else if (value === notes[i][field]) {
						note_list.push(notes[i].title)
					}
				}
			}
		}

		return note_list
	}

	// Export a note by a title or by id
	this.export_note = function(title, id = null) {
		if (id === null) id = titles[title]

		var note_json = ""
		var note = notes[id]

		for (var field in note) {
			var value = note[field]
			var type = typeof(value)
			var wrap = ""
			
			if (type === "string") {
				wrap = "`"

				// Replace certain symbols that interfere with JavaScript's multiline strings
				// [ \ ] 	-> [ \\ ]
				// [ ` ] 	-> [ \` ]
				// [ ${ ] 	-> [ \${ ]
				// Also break up any script closing tags
				value = value.
				replaceAll("\\", "\\\\").
				replaceAll("`", "\\`").
				replaceAll("${", "\\${").
				replaceAll("</"+"script>", "</${'script'}>")
			}
			
			if (note_json.length != 0) note_json += ",\n"
			
			note_json += field + ":" + (wrap + value + wrap)
		}

		return "{\n" + note_json + "\n}"
	}
	
	// Generate a string of JS code that will replicate the note storage memory structure
	// Holes are removed
	this.cold_storage_snapshot = function() {
		var result = ""
		
		for (var id = 0; id < notes.length; id++) {
			if (id in notes === false) continue

			var note_json = this.export_note(null, id)
			
			if (result.length != 0) result += ",\n"
			result += note_json
		}
		
		return "[" + result + "]"
	}
	
	// Restore from an already evaluated snapshot
	this.cold_storage_restore = function() {
		notes = ias_cold_storage
		this.update_title_hashmap()
	}

	// Float the note to bottom
	// Will leave holes in the note array
	// Used as a mechanism to fight excessive truncation
	this.float_to_bottom = function(title) {
		var id = titles[title]
		
		// Return if note is already at the bottom
		if (id === notes.length - 1) {
			return
		}

		var note = notes[id]

		delete notes[id]

		var new_id = notes.push(note) - 1
		titles[title] = new_id
	}
	
	// Needs to be called after restoring from snapshot
	this.update_title_hashmap = function() {
		for (var id = 0; id < notes.length; id++) {
			var title = notes[id].title
			titles[title] = id
		}
	}

	// Fire this to alert things that note storage was modified
	//
	// Currently supported alerts
	// - note_created
	// - note_altered
	// - note_renamed
	// - note_deleted
	//
	this.fire_alert = function(alert, cause) {
		story.alert(alert, cause)
		story.alert_all_notes(alert, cause)

		search.alert(alert, cause)
		navbar.alert(alert, cause)
		dropdown.alert(alert, cause)
	}

	// Reveal or update debug pointers
	this.reveal_pointers = function() {
		this.notes = notes
		this.titles = titles
	}
	// ==============================================================================
}

ias.bootloader = function() {
	//
	// IAS bootloader
	//
	// ==============================================================================
	this.init = function() {
		window.onerror = this.handle_error
		window.onunhandledrejection = this.handle_error
		window.log = console.log

		// Can be any object
		var root = window
		
		root.bootloader = this

		// Initialize an instance of EVERYTHING that was added into window.ias
		for (var component in ias) {
			root[component] = new window.ias[component]
		}

			
		root.core.cold_storage_restore()

		// Delete the original cold storage reference
		// Now referenced by core.notes
		delete window.ias_cold_storage

		// Initial app start
		navbar.init()
		dropdown.init()

		story.open_note("Warning")
		story.open_note("Search")

		// Check whether the URL is clean of anchors
		// If yes, open the default note
		// Otherwise, open the linked note
		if (location.hash === "") {
			//story.open_note( default_note )
		} else {
			story.open_note( decodeURI(location.hash.slice(1)) )
		}

	}

	// JavaScript error handler
	this.handle_error = function(description, url, line, column, error) {
		if ("crash_count" in window === false) {
			window.crash_count = 0
		}

		crash_count++

		// Special handling for errors that occured within Async functions
		// Seems to be Firefox-specific to consider async errors promise rejections
		// Chromium considers async errors normal errors
		if (typeof(description) === "object") {
			if ("reason" in description) {
				var reason = description.reason

				description = reason.message
				url = reason.fileName
				line = reason.lineNumber
				column = reason.columnNumber
				error = {}
				error.stack = reason.stack
			}
		}

		var stack_trace = ""

		if (error === undefined) {
			stack_trace = " --- NO ERROR INFO AVAILABLE --- "
		} else if ("stack" in error === false) {
			stack_trace = " --- NO STACK TRACE AVAILABLE --- "
		} else {
			// Firefox specific prettyfication
			// Doesn't break chromium
			stack_trace = error.stack.replace(/\n@/g, "\nanonymous@").replace(/@/g, "   @   ").replace(/\n/g, "\n\t")
		}

		var message = ""
		+ " === Crash report #" + crash_count + " === \n"
		+ "A crash has occurred in:\n"
		+ "<"+url+">:"+line+" --- " + description + "\n\n"
		+ "Stack trace: \n	" + stack_trace + "\n\n"
		+ "A restart is advised.\n\n"
		
		alert(message)
	}

	this.hash = "aaaaad0b03231ca27d61173c145a3b3c18b977b4742de578710fab0478251ae0"
	// ==============================================================================
}

ias.utils = function() {
	//
	// IAS misc utils
	//
	// ==============================================================================

	// List of APIs:
	// - q_id(...)
	// - q_sel(...)
	// - add(tagname, parent, id)
	// - adjacent_add(tagname, target, where, id)
	// - dom_reverse_traverse(element, target_tag)
	// - strectes_beyond_viewport(element)
	// - error(text)
	// - success(text)
	// - show_status(text)
	// - hide_status()
	// - format_time(timestamp)
	// - get_new_title()
	// - apply_css(css)
	// - display_title(title)
	// - display_tags(tags)
	// - display_tag(tag)
	//

	// Alias
	var utils = this

	// Query ID alias
	window.q_id = document.getElementById.bind(document)

	// Query selector alias
	window.q_sel = document.querySelector.bind(document)
	
	// Make an element helper
	window.add = function(tagname, parent = document.body, id = null) {
		var element = document.createElement(tagname)
		
		if (id != null) element.id = name
		parent.appendChild(element)
		
		return element
	}

	// Make an adjacent element helper
	// Where can be:
	// - beforebegin
	// - afterbegin
	// - beforeend
	// - afterned
	window.adjacent_add = function(tagname, target, where = "beforebegin", id = null) {
		var element = document.createElement(tagname)
		
		if (id != null) element.id = name
		target.insertAdjacentElement(where, element)
		
		return element
	}

	// Walk up the DOM tree until a <TARGET_TAG> element is found
	// Note: target tag must be in ALL CAPS
	window.dom_reverse_traverse = function(element, target_tag) {
		// Reached the absolute top
		if ("parentElement" in element === false) {
			return false
		}

		if (element.parentElement.tagName === target_tag) {
			return element
		} else {
			return dom_reverse_traverse(element.parentElement, target_tag)
		}
	}

	// Check if a part of the element, or the entire element, stretches beyond the viewport
	window.stretches_beyond_viewport = function(element) {
		return (window.innerHeight + window.scrollY < element.offsetTop + element.scrollHeight)
	}


	window.error = function(text) {
		show_status(text)

		statusbox.classList.add("error")
	}

	window.success = function(text) {
		show_status(text)

		statusbox.classList.add("success")
		setTimeout(hide_status, 5000)
	}

	// Display a status box in the status area
	window.show_status = function(text) {
		if ("statusbox" in window === false) {
			window.statusbox = add("div", q_sel("body .status_area"))
			statusbox.classList.add("status_box")
		}
		
		statusbox.classList.remove("success")
		statusbox.classList.remove("error")
		statusbox.classList.remove("hide")
		statusbox.innerHTML = text

		statusbox.onclick = hide_status
	}

	window.hide_status = function() {
		statusbox.classList.add("hide")
	}

	// Get a formatted time string
	// Converts supplied timestamp to local format
	utils.format_time = function(timestamp) {
		return new Date(timestamp).toLocaleString(locale.date_format, locale.date_options)
	}

	// Return a title for a new note
	utils.get_new_title = function() {
		return locale.new_note_title + (core.get_note_count() + 1)
	}

	// Switch to a new CSS
	// Not additive, replaces CSS fully
	utils.apply_css = function(css) {
		var style = q_sel("style")

		if (style === null) {
			style = add("style", document.head)
		}

		style.innerText = css
	}

	// Format a note title into a clickable link
	utils.display_title = function(title, open_after = "") {
		return "<a class=\"internal auto\" href=\"#"+title+"\" onclick=\"story.open_note('"+title.replace(/'/g, "\\'")+"', '"+open_after+"'); return false;\">"+title+"</a>"
	}

	// Format an array of tags into a set of pillows
	utils.display_tags = function(tags) {
		var html = "<span class=\"tag_list\">"
		var len = tags.length

		for (var i = 0; i < len; i++)
			html += utils.display_tag(tags[i])

		return html + "</span>"
	}

	// Format a single tag into a <span> pillow
	utils.display_tag = function(tag) {
		// Regular expression to detect symbols not safe to place inside an HTML attribute
		var rxp_unsafe = /[^\w-]/g

		return "<span class=\"tag tg-" + tag.replace(rxp_unsafe, "") + "\">" + tag + "</span>"
	}
	// ==============================================================================
}

ias.story = function() {
	//
	// IAS GUI; story
	//
	// ==============================================================================

	// Shortcut
	var story = this

	story.entries = {}

	// Shortcut 2
	var entries = story.entries

	// Alert the story that a note changed
	this.alert = function(alert, cause) {
		if (cause in entries === false) {
			return
		}

		var note = entries[cause]

		// On alterations, reload the note
		if (alert === "note_altered") {
			note.reload()
		}

		// On renames, remove the stale title and re-add the note under a new title
		if (alert === "note_renamed") {
			delete entries[cause]
			entries[note.info.title] = note
			note.ui.set_title(note.info.title)
		}

		// On deletions, close the note
		if (alert === "note_deleted") {
			note.close()
		}
	}

	// Alert all notes within the story
	// If entries[cause] exists, run the edited/renamed/deleted checks
	// Then, for every open note, call a function note[alert]() if available
	this.alert_all_notes = function(alert, cause) {
		for (var title in entries) {
			var note = entries[title]

			if (alert in note.alerts) {
				note.alerts[alert](cause)
			}
		}
	}

	// Create a brand new note (And start editing it)
	this.create_new_note = function() {
		var title = utils.get_new_title()
		var note = story.new_empty_note()

		note.info = core.create_note(title)
		note.reload()
		note.edit()
	}

	// Create a temporary note not backed by the note storage
	this.create_temporary_note = function(after = null) {
		var note = story.new_empty_note(after)

		note.display_temporary_toolbar()
		note.ui.set_title("<i>Temporary note</i>")
		note.ui.set_date(utils.format_time( Date.now() ))

		return note
	}

	// A new empty note within the story
	// Completely empty, but with all the APIs ready to operate
	this.new_empty_note = function(after = null) {
		var note = {}

		note.ui = {}
		note.ui.box = document.createElement("div")
		note.ui.box.classList.add("box")

		// If no "after" specified, simply insert the note as a new child in the <content>
		// Otherwise perform adjacent insertion to the target element
		if (after === null) {
			var story_river = q_sel("body content")
			story_river.appendChild(note.ui.box)
		} else {
			if (after in entries) {
				var previous_note = entries[after]
				previous_note.ui.box.insertAdjacentElement("afterend", note.ui.box)
			} else {
				log("Tried to insert a note after ["+after+"] but was unable to find it within the story!")
				var story_river = q_sel("body content")
				story_river.appendChild(note.ui.box)
			}
		}
		
		// Install the APIs and the HTML structure
		story.install_note_ui(note)
		story.install_note_logic(note)

		return note
	}

	// Open a note within the story river
	this.open_note = function(title, after = null) {
		// We do not respect notes with empty title
		if (title === "") {
			log("Can't open a note that has no title.")
			return
		}

		// Check whether the note is already open
		// If so, scroll to it and make it blink
		if (title in entries === true) {
			var note = entries[title]
			
			note.ui.scroll_to()
			note.ui.blink()

			return note
		}

		// Check whether the note exists
		// If no, suggest to create it
		if (core.note_exists(title) === false) {
			story.suggest_note(title)
			return
		}



		// Obtain a direct reference to the note
		var info = core.get_note_reference(title)

		// If note is to be executed as a process, we shouldn't create any UIs for it
		// Just run it async and exit
		if (info.execute === "process") {
			var code = core.get_note_text(title)
			var run = new AsyncFunction(code)
			run()

			return
		}
		

		// Otherwise, we need to initialize the UI + logic
		var note = story.new_empty_note(after)

		note.info = info
		note.reload()

		return note
	}

	// Suggest to create a note
	this.suggest_note = function(title) {
		var note = story.new_empty_note()

		note.display_suggestion_toolbar()

		note.ui.set_title(title.italics())
		note.ui.set_date(utils.format_time( Date.now() ))
		note.ui.set_body(locale.note_missing)

		note.ui.scroll_to()
	}

	// Note UI creation and some basic APIs
	// Requires object to have a content box
	//
	// List of APIs:
	// - set_title(text)
	// - set_date(text)
	// - set_body(text)
	// - scroll_to()
	// - blink()
	// - body.q_sel(selector)
	// - clear_buttons()
	// - add_toolbar_button(name, text)
	// - add_menu_button(name, text)
	//
	this.install_note_ui = function(note) {
		//
		// STAGE 1: Structure
		//

		// Note consist of the header, the body and the (hidden) editor
		note.ui.header 			= add("div", note.ui.box)
		note.ui.body 			= add("div", note.ui.box)
		note.ui.editor			= add("textarea", note.ui.box)

		// Header contains the tools, the title and the date
		note.ui.title 	= add("div", note.ui.header)
		note.ui.tools 	= add("div", note.ui.header)
		note.ui.date 	= add("div", note.ui.header)

		// Div to store toolbar buttons
		note.ui.buttons = add("div", note.ui.tools)

		// More menu
		note.ui.menu_root 	= add("div", note.ui.tools)
		note.ui.menu 		= add("div", note.ui.menu_root)

		// Set up CSS classes
		note.ui.header.classList.add("note_header")
		note.ui.editor.classList.add("note_editor")
		note.ui.title.classList.add("title")
		note.ui.tools.classList.add("tools")
		note.ui.date.classList.add("date")
		note.ui.body.classList.add("note_body")

		note.ui.buttons.classList.add("toolbar")

		note.ui.menu_root.classList.add("dropdown_root")
		note.ui.menu.classList.add("dropdown", "hide")

		// Hide the editor
		note.ui.editor.hidden = true

		//
		// STAGE 2: Title and Body functions
		//

		note.ui.editor.oninput = function() {
			note.ui.editor.style.height = note.ui.editor.scrollHeight + "px"
		}

		note.ui.title.onkeypress = function() {
			if (event.key === "Enter") {
				event.preventDefault()
			}
		}

		note.ui.set_title = function(title) { note.ui.title.innerHTML 	= title }
		note.ui.set_date = function(date) 	{ note.ui.date.innerHTML 	= date }
		note.ui.set_body = function(text) 	{ note.ui.body.innerHTML 	= text }

		note.ui.scroll_to = function() {
			note.ui.box.scrollIntoView({behavior: "smooth", block: "nearest"})
		}

		note.ui.blink = function() {
			note.ui.box.classList.add("attention")
			setTimeout(note.ui.unblink, 50)
		}

		note.ui.unblink = function() {
			note.ui.box.classList.remove("attention")
		}

		note.ui.body.q_sel = function(selector) {
			return note.ui.body.querySelector(selector)
		}
		
		//
		// STAGE 3: Toolbar functions
		//

		// Object to house the buttons
		note.buttons = {}

		// Removes all buttons from the toolbar and the menu
		note.ui.clear_buttons = function() {
			for (var name in note.buttons) {
				note.buttons[name].delete_button()
			}
		}

		// Add a button
		// Requires the note to have a handler function with a matching name
		note.ui.add_button = function(name, text, parent) {
			// 1. Create a button
			note.buttons[name] = add("button", parent)

			// 2. Set the name
			note.buttons[name].innerText = text

			// 3. Button deletion function
			note.buttons[name].delete_button = function() {
				note.buttons[name].remove()
				delete note.buttons[name]
			}

			// 4. Handler function
			// Check whether the handler function exists
			// If it does, hook it up
			// Otherwise complain
			if (name in note) {
				note.buttons[name].onclick = note[name]
			} else {
				log("Added a button \"" + text + "\" but couldn't find a handler function!")
			}
		}

		// Helpers to add:
		// 1. A toolbar button
		// 2. A menu button
		note.ui.add_toolbar_button 	= function(name, text) { note.ui.add_button(name, text, note.ui.buttons) }
		note.ui.add_menu_button 	= function(name, text) { note.ui.add_button(name, text, note.ui.menu) }
	}

	// Higher-level note logic
	//
	// List of APIs:
	// - display_default_toolbar()
	// - display_editing_toolbar()
	// - display_suggestion_toolbar()
	// - more()								BUTTON HANDLER
	// - edit()								BUTTON HANDLER
	// - close()							BUTTON HANDLER
	// - delete()							BUTTON HANDLER
	// - abort()							BUTTON HANDLER
	// - save()								BUTTON HANDLER
	// - create()							BUTTON HANDLER
	// - reload()
	this.install_note_logic = function(note) {
		// Alert handlers
		note.alerts = {}

		// Default toolbar
		// Tools feature the "close", "edit" and "more" buttons (At least for this pathfinder version)
		note.display_default_toolbar = function() {
			note.ui.clear_buttons()

			note.ui.add_toolbar_button("more", "More")
			note.ui.add_toolbar_button("edit", "Edit")
			note.ui.add_toolbar_button("close", "Close")

			note.ui.add_menu_button("find_similar", "Find similar notes")
			note.ui.add_menu_button("export", "Export note")
		}

		// Editing toolbar
		// Tools feature the "delete", "abort" and "save" buttons
		note.display_editing_toolbar = function() {
			note.ui.clear_buttons()

			note.ui.add_toolbar_button("delete", "Delete")
			note.ui.add_toolbar_button("abort", "Abort")
			note.ui.add_toolbar_button("save", "Save")
		}

		// Temporary note toolbar
		// Only the "close" button
		note.display_temporary_toolbar = function() {
			note.ui.clear_buttons()

			note.ui.add_toolbar_button("close", "Close")
		}

		// Suggested note toolbar
		// "Create" and "close" buttons
		note.display_suggestion_toolbar = function() {
			note.ui.clear_buttons()

			note.ui.add_toolbar_button("create", "Create")
			note.ui.add_toolbar_button("close", "Close")
		}

		//
		// STAGE 4: Button handlers
		//

		// Close the note
		note.close = function() { 
			note.ui.box.remove()

			if ("info" in note) {
				delete entries[note.info.title]
			}
		}

		// Enter editing mode
		note.edit = function() { 
			note.display_editing_toolbar() 

			// Pull the unprocessed text (pre-markdown or pre-execution)
			var raw_text = core.get_note_text(note.info.title)
			note.ui.editor.value = raw_text

			note.ui.title.classList.add("editing")
			note.ui.title.contentEditable = true

			note.ui.editor.hidden = false
			note.ui.editor.style.height = note.ui.editor.scrollHeight + "px"
			note.ui.body.hidden = true

			// Focus editor if doing so will not cause the page to scroll
			if (stretches_beyond_viewport(note.ui.editor) === false) {
				note.ui.editor.focus()
			}
		}

		// Display more buttons
		note.more = function() { note.ui.menu.classList.toggle("hide") }


		// Delete the note
		note.delete = function() { 
			var really_delete = confirm("Delete note \"" + note.info.title + "\"\n\nAre you sure?")

			if (really_delete === true) {
				note.close()
				core.delete_note(note.info.title)
			}
		}

		// Abort editing
		note.abort = function() { 
			note.display_default_toolbar()

			note.ui.title.contentEditable = false
			note.ui.title.classList.remove("editing")
			note.ui.title.innerText = note.info.title
			
			note.ui.editor.value = ""
			note.ui.editor.style.height = ""
			note.ui.editor.hidden = true
			note.ui.body.hidden = false
		}

		// Save edits
		note.save = function() {
			// Harvest the text
			var text = note.ui.editor.value

			// Harvest the title (old and new)
			var old_title = note.info.title
			var new_title = note.ui.title.innerText.trim()

			// Hide the editor
			note.abort()

			// Check whether the title was altered
			// If it was, call the rename function
			// alert_all_notes() will update the story
			if (old_title != new_title) {
				core.rename_note(old_title, new_title)
			}
			
			// Update the contents
			// Should trigger an automatic reload
			core.set_note_text(new_title, text)
		}

		// Create button on suggested notes
		note.create = function() { 
			var title = note.ui.title.innerText

			note.info = core.create_note(title)

			note.reload()
			note.edit()
		}

		// Find similar notes
		note.find_similar = function() { 
			var results = search.lunr_find_similar(note.info.title)

			var results_note = story.create_temporary_note(note.info.title)
			var htmlcode = ""
			var len = results.length

			// Display the self-similarity first and foremost
			var entry = results[0]
			htmlcode += "Self-similarity: " + entry.score

			htmlcode += "<ul>"

			for (var i = 1; i < len; i++) {
				var entry = results[i]
				htmlcode += "<li>" + utils.display_title(entry.title, note.info.title) + "<br>Similarity: " + entry.score + "<br>Tags: " + utils.display_tags(entry.tags) + "</li>\n" 
			}

			htmlcode += "</ul>"

			results_note.ui.set_title("<i>Find similar: " + note.info.title + "</i>")
			results_note.ui.set_body(htmlcode)
			results_note.ui.scroll_to()
		}

		// Export this note in particular
		note.export = function() {
			networking.download(core.export_note(note.info.title), note.info.title + ".jsbit")
		}

		// Reload function 
		// Text notes: 	fetch the text, parse it as markdown and display it
		// App notes: 	fetch the text and run it
		note.reload = async function() {
			var title = note.info.title

			log("Reloading [" + title + "]")

			// Display the default toolbar
			note.display_default_toolbar()

			// Update the note UI title
			note.ui.set_title(title)

			// Update the story entry
			entries[title] = note

			// Fetch the text/code
			// Remotely if needed
			var text = ""

			if ("remote_url" in note.info) {
				var url = note.info.remote_url

				note.ui.set_body(" --- REMOTE FETCH IN PROGRESS --- ")
				show_status("Downloading [" + url + "]...")

				text = await networking.get(url)

				if (text === null) {
					text = " --- REMOTE FETCH FAILURE --- "
				} else {
					success("Downloading [" + url + "]...OK")
				}
			} else {
				text = core.get_note_text(title)
			}

			if ("execute" in note.info) {
				if (note.info.execute === "app") {
					note.ui.set_date("") // Apps don't show a date by default
					note.ui.set_body("")

					var run = new AsyncFunction("note", text)
					run(note)
				}
			} else {
				note.ui.set_date(utils.format_time(note.info.modification_date))
				note.ui.set_body(text) // Markdown goes here
			}

			note.ui.scroll_to()
		}

	}

	this.handle_anchor_change = function() {
		var target_note = decodeURI(location.hash.slice(1))
		story.open_note(target_note)
	}

	window.onhashchange = story.handle_anchor_change

	// ==============================================================================
}

ias.navbar = function() {
	//
	// IAS GUI; navbar
	//
	// ==============================================================================

	// Alias
	var navbar = this

	navbar.buttons = {}
	navbar.handlers = {}

	navbar.init = function() {
		navbar.button_area = q_sel(".nav_buttons")
		navbar.menu_area = q_sel(".nav_dropdown")
		navbar.search = q_sel(".nav_search")
		navbar.display_default_navbar()

		navbar.search.placeholder = locale.search_placeholder

		navbar.current_theme = "" //"/ias/themes/default"
		navbar.apply_theme()
	}

	navbar.clear = function() {
		for (var name in navbar.buttons) {
			navbar.buttons[name].delete_button()
		}
	}

	// Add a navbar button
	navbar.add_button = function(name, text) {
		// 1. Create a button
		navbar.buttons[name] = add("button", navbar.button_area)

		// 2. Set the name
		navbar.buttons[name].innerText = text

		// 3. Button deletion function
		navbar.buttons[name].delete_button = function() {
			navbar.buttons[name].remove()
			delete navbar.buttons[name]
		}

		// 4. Handler function
		navbar.buttons[name].onclick = navbar.handlers[name]
	}

	navbar.display_default_navbar = function() {
		navbar.clear()

		navbar.add_button("create_new_note", 	"New note")
		navbar.add_button("open_settings", 		"Settings")
		navbar.add_button("save", 				"Save")
		navbar.add_button("switch_theme", 		"Theme")
		navbar.add_button("toggle_more", 		"More")
		navbar.add_button("toggle_search", 		"Search")
	}

	navbar.handlers.create_new_note = 	function() { story.create_new_note() }
	navbar.handlers.open_settings = 	function() { alert("UNIMP") }
	navbar.handlers.save = 				function() { singlefile_saver.save() }
	navbar.handlers.switch_theme = 		function() { alert("UNIMP") }
	navbar.handlers.toggle_more = 		function() { dropdown.toggle() }
	navbar.handlers.toggle_search = 	function() { story.open_note("Search") }

	// Highlight the save button to warn that you have pending changes
	navbar.post_save_warning = function() { navbar.buttons.save.classList.add("alert") }
	navbar.clear_save_warning = function() { navbar.buttons.save.classList.remove("alert") }

	// Storage alerts handler
	navbar.alert = function(alert, cause) {
		// Activate the "unsaved changes" warning light
		navbar.post_save_warning()

		// If theme changed, re-apply it
		if (alert === "note_altered" && cause === navbar.current_theme) {
			navbar.apply_theme()
		}
	}

	// (Re)apply the theme
	navbar.apply_theme = function() {
		if (core.note_exists(navbar.current_theme)) {
			var css = core.get_note_text(navbar.current_theme)
			utils.apply_css(css)
		} else {
			log("Theme switcher: note [" + navbar.current_theme + "] does not exist")
		}
	}

	// ==============================================================================
}

ias.dropdown = function() {
	//
	// IAS GUI; Dropdown navigation menu
	//
	// ==============================================================================
	
	// Dropdown menu is the menu unveiled by clicking "more" button in the navbar
	//

	// Alias
	var dropdown = this
	var open = false
	var elem

	dropdown.init = function() {
		elem = q_sel(".nav_dropdown")
	}

	dropdown.toggle = function() {
		open = elem.classList.contains("open")

		if (open === false) {
			elem.classList.add("open")
			open = true

			dropdown.update()
		} else {
			elem.classList.remove("open")
			open = false
		}
	}

	dropdown.alert = function(alert, cause) {
		if (open) {
			dropdown.update()
		}
	}

	dropdown.update = function() {
		elem.innerHTML = ""

		elem.innerHTML += dropdown.get_recent_notes()
		elem.innerHTML += dropdown.get_apps()
	}

	dropdown.get_recent_notes = function() {
		var htmlcode = "<h1>Recent notes</h1><hr>"

		var titles = core.get_recent_titles(20)
		var count = titles.length

		for (var i = 0; i < count; i++) {
			htmlcode += dropdown.make_link(titles[i])
		}

		return htmlcode
	}
	
	dropdown.get_apps = function() {
		var htmlcode = "<h1>Apps</h1><hr>"

		var titles = core.get_notes_with_field("execute")
		var count = titles.length

		for (var i = 0; i < count; i++) {
			htmlcode += dropdown.make_link(titles[i])
		}

		return htmlcode
	}

	dropdown.make_link = function(title) {
		return `<a class="internal auto" href="#${title}" onclick="story.open_note('${title}'); return false;">${title}</a><br>`
	}



	// ==============================================================================
}

ias.networking = function() {
	//
	// IAS networking
	//
	// ==============================================================================

	// Download some data as a file
	this.download = function(data, name) {
		var type = "text/html";
		var blob = new Blob([data], {'type': type});
		var url = URL.createObjectURL(blob);

		var anchor = add("a")

		anchor.href = url
		anchor.download = name

		anchor.click()
		anchor.remove()
	}

	// Upload some data using PUT
	this.put = async function(data, address) {
		var payload = {method: "PUT", body: data}

		try {
			var response = await fetch(address, payload)
		} catch (err) {
			error(locale.network_error)
			return null
		}

		if (response.status === 200 || response.status === 204) {
			var text_response = await response.text()
			return text_response
		} else {
		    error(locale.server_error + "<hr>" + locale.error_code + response.status + "<br>" + locale.address + address)
		    return null
		}
	}

	// Download some data using GET
	this.get = async function(address) {
		try {
			var response = await fetch(address)
		} catch (err) {
			error(locale.network_error)
			return null
		}

		if (response.status === 200) {
			var text_response = await response.text()
			return text_response
		} else {
		    error(locale.server_error + "<hr>" + locale.error_code + response.status + "<br>" + locale.address + address)
			return null
		}
	}
	// ==============================================================================
}

ias.singlefile_saver = function() {
	//
	// IAS saving code
	//
	// ==============================================================================

	// Save as a single HTML file
	// Two endpoints supported:
	// - Browser download
	// - PUT request to server
	//
	// If IAS was loaded via HTTP/HTTPS, save() will automatically switch to PUT.
	// 		Correction: no, it will not, not at this time.
	//

	//
	// List of APIs:
	// - save()
	// - make_banner(text) 				INTERNAL
	// - save_component(name)			INTERNAL
	// - save_all_components()			INTERNAL
	// - save_notes()					INTERNAL
	// - build_file_text()				INTERNAL
	//

	this.make_banner = function(text) {
		return "//\n// " + text + "\n//\n"
	}

	this.js_open = "<script>\n\"use strict\";\n\n"
	this.js_close = "</" + "script>\n" 

	this.html_template_start = 
	  "<!DOCTYPE html>"
	+ "<html>"
	+ "<head><meta charset=\"utf-8\"><title>IAS</title><link rel=\"stylesheet\" href=\"style.css\"><link rel=\"stylesheet\" href=\"tags.css\"></head>"
	+ "<body>"
	+ "<nav><div class=\"nav_topbar\"><div class=\"nav_buttons\"></div><input type=\"text\" class=\"nav_search\"></div><div class=\"nav_dropdown\"></div></nav>"
	+ "<div class=\"status_area\"></div>"
	+ "<content>"
	+ "<noscript><div class=\"box\"><p>Can't work without JavaScript, unfortunately.</p></div></noscript>"
	+ "</content>\n"
	+ "<" + "script src=\"lunr.js\"></" + "script>\n"
	+ "<!-- JUMP TO BOTTOM OF THE FILE TO FIND THE ENTRY POINT -->\n"
	+ this.js_open
	+ "// Source object\n"
	+ "// Stores the source code of the API Servers / components\n"
	+ "// bootloader.init() will initialize them:\n"
	+ "// - ias.core -> window.core\n"
	+ "// - ias.story -> window.story\n"
	+ "// - ias.locale -> window.locale\n"
	+ "// - etc...\n"
	+ "//\n"
	+ "// Only after initialization can you use them!\n"
	+ "//\n"
	+ "var ias = {}\n"
	+ this.js_close
	+ "\n"

	this.html_template_end = 
	  "</body></html>"
	
	this.entry_point_template = 
	  this.js_open
	+ this.make_banner("IAS entry point")
	+ "var bootloader = new ias.bootloader()\n"
	+ "bootloader.init()\n"
	+ this.js_close



	this.save_component = function(name) {
		return "ias." + name + " = " + ias[name].toString() + "\n\n"
	}

	this.save_all_components = function() {
		var result = ""

		for (var component in ias) {
			result += this.save_component(component)
		}

		return result
	}

	this.save_notes = function() {
		return "window.ias_cold_storage = " + core.cold_storage_snapshot() + "\n\n"
	}

	this.build_file_text = function() {
		var result = ""

		result += this.js_open + this.save_all_components() + this.js_close

		result += this.js_open
		result += this.make_banner("IAS cold storage")
		result += this.save_notes()
		result += this.js_close

		return this.html_template_start + result + this.entry_point_template + this.html_template_end
	}

	// Save this copy of IAS as a file
	this.save = async function() {
		var protocol = location.protocol

/*		// For HTTP or HTTPS attempt to save via PUT request
		// Otherwise download a copy to the user's machine
		if (protocol === "http:" || protocol === "https:") {
			var result = await networking.put(this.build_file_text(), "ias.html")

			if (result === false) {
				error(locale.saving_error)
				return
			}
		} else {
			alert("Warning! External dependencies.\n\nFollowing files are not integrated into the unified HTML at this time:\n - style.css\n - lunr.js\n\nYou'll need to download them separately and place them next to the .html file.")
			networking.download(this.build_file_text(), "ias.html")
		}*/

		alert("Warning! External dependencies.\n\nFollowing files are not integrated into the unified HTML at this time:\n - style.css\n - tags.css\n - lunr.js\n\nYou'll need to download them separately and place them next to the .html file.")
		networking.download(this.build_file_text(), "ias.html")

		success(locale.saving_ok)
		navbar.clear_save_warning()
	}
	// ==============================================================================
}

ias.search = function() {
	//
	// IAS search
	//
	// ==============================================================================
	
	// Alias
	var search = this

	// Substring search through the titles
	// Case-insensitive
	search.search_titles = function(pattern) {
		var matches = []

		core.for_each_note( function(note) {
			if (note.title.toLowerCase().includes(pattern))
				matches.push(note.title)
		} )

		return matches
	}

	// Naive full text search
	// Case-insensitive
	search.search_text = function(pattern) {
		var matches = []

		core.for_each_note( function(note) {
			if (note.body.toLowerCase().includes(pattern))
				matches.push(note.title)
		} )

		return matches
	}

	search.lunr_search_text = function(text) {
		// Initialize if no init yet
		if ("lunr" in search === false) {
			log("Initializing lunr... please hold on")
			search.reinit_lunr()
		}

		var results = search.lunr.search(text)
		var len = Math.min(10, results.length)

		for (var i = 0; i < len; i++) {
			var id = results[i].ref

			results[i].title = search.idx._documents[id].note.title
			results[i].tags = search.lunr_auto_tags("a/" + id)

			//log(results[i].tags, id)
		}

		//log(results.length, "hits in total. Keep refining your query!")

		return results.slice(0, len)
	}

	// Calculate inverse document frequency for a term if lunr hidden fields are exposed
	search.lunr_idf = function(term) {
		//var term = search.lunr.pipeline.runString(token)

		// Shoddy lunr IDF that takes multiple fields into account and uses some math on top
		// Prime candidate for replacement with a classic version
		return lunr.idf(search.lunr.invertedIndex[term], search.idx.documentCount)
	}

	// Attempt to automatically tag a document
	// Returns 10 top terms
	search.lunr_auto_tags = function(id) {
		var tf = search.idx.fieldTermFrequencies[id]

		var distinct_tems = 0
		var list = {}

		for (var term in tf) {
			var score = tf[term] * search.lunr_idf(term)
			list[term] = score
			distinct_tems++
		}

		var max_tags = Math.min(10, distinct_tems)
		var top = []

		for (var i = 0; i < max_tags; i++) {
			var max_value = 0.0
			var max_term

			for (var term in list) {
				var value = list[term]

				if (value > max_value) {
					max_value = value
					max_term = term
				}
			}

			top.push(max_term)
			delete list[max_term]
		}

		return top
	}

	// Attempt to find documents with a similar document-space vector
	search.lunr_find_similar = function(title) {
		var id = search.idx_find_note_id(title)
		var doc = search.lunr.fieldVectors[id]

		if (doc === undefined) {
			log("Document not found")
			return null
		}

		// Two arrays
		// One keeps scores, the other IDs
		var score_list = []
		var id_list = []

		// Perform a vector dot product with every other document
		for (var other_id in search.lunr.fieldVectors) {
			// Skip self
			if (other_id === id) continue

			var other_doc = search.lunr.fieldVectors[other_id]

			score_list.push( doc.dot(other_doc) )
			id_list.push( other_id )
		}

		// Declare the top 10 (11 actually) array		
		var len = score_list.length
		var top = []

		// First entry is the self-similarity
		var self_similarity = {score: Math.round(doc.dot(doc)), title: title, tags: null}
		top.push(self_similarity)

		// Sort through all the results and pick out a top 10
		for (var i = 0; i < 10; i++) {
			var max_value = 0.0
			var max_id = 0

			for (var j = 0; j < len; j++) {
				var value = score_list[j]

				if (value > max_value) {
					max_value = value
					max_id = j
				}
			}

			var entry_id = id_list[max_id]
			var entry = {score: Math.round(score_list[max_id]), title: search.idx_get_note_title(entry_id), tags: search.lunr_auto_tags(entry_id) }
			score_list[max_id] = 0.0

			top.push( entry )
			
		}

		return top
	}

	// Discover neighboring terms
	search.lunr_discover_nearby = function(word) {
		var term = search.lunr.pipeline.runString(word)

		if (term in search.lunr.invertedIndex === false) {
			return null
		}

		var next = []
		var prev = []

		var count = 5
		var idx = search.lunr.invertedIndex[term]._index

		for (var other_term in search.lunr.invertedIndex) {
			var entry = search.lunr.invertedIndex[other_term]
			var delta = idx - entry._index

			if (delta > 0 && delta <= count) {
				prev[count - delta] = other_term
			} else if (delta < 0 && delta >= -count) {
				next[-delta] = other_term
			}
		}

		log(prev.toString().replaceAll(",", " --> ") + " --> " + term + next.toString().replaceAll(",", " --> "))
	}

	// Re-initialize lunr from .idx object
	// Creates following objects:
	// - search.lunr 				The main lunr object
	//
	// Depends on the following:
	// - search.idx.invertedIndex			Index that maps terms to document IDs
	// - search.idx.fieldTermFrequencies	Index that maps document IDs to the distinct terms they contain, plus the encounter rate for each term
	// - search.idx.fieldLengths			Index that maps document IDs to their total term count
	// - search.idx._documents				Index that maps document IDs to whatever metadata was provided
	// - search.idx.documentCount			Integer, total document count
	search.reinit_lunr = function() {
		log("Re-initializing lunr...")

		if ("idx" in search === false) {
			log("No pre-restored/pre-baked indices found! Falling back to generating one from scratch.")
			search.init_lunr_from_notes()
			return
		}

		// Nuke if exists
		delete search.lunr

		search.lunr = lunr(function () {
			// Reset the default pipelines
			this.pipeline.reset()
			this.searchPipeline.reset()

			// Then set them up again but with our custom stemmer
			this.pipeline.add(
				lunr.trimmer,
				lunr.stopWordFilter,
				search.partial_stemmer
			)

			this.searchPipeline.add(
				search.partial_stemmer
			)

			// Only one field to index
			// Shortest possible name to use less RAM
			this.field('a')
			this.ref('id')

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex
		})

		log("Complete!")
	}

	// First time search.idx bootstrapping
	// Creates following objects:
	// - search.idx 				A set of primary and secondary indices, some previously hidden
	search.init_lunr_from_notes = function() {
		log("Initializing lunr from scratch...")

		search.lunr = lunr(function () {
			this.pipeline.reset()
			this.searchPipeline.reset()

			this.pipeline.add(
				lunr.trimmer,
				lunr.stopWordFilter,
				search.partial_stemmer
			)

			this.searchPipeline.add(
				search.partial_stemmer
			)

			this.field('a')
			this.ref('id')

			// Temporary alias that's visible from within the core.for_each_note()
			var temp_ref = this

			// Growing ID
			var gid = 0

			core.for_each_note(function(note) {
				// Use documentCount to generate IDs
				// Store direct references in _documents
				temp_ref.add({id: gid, a: note.body}, {note: note})
				gid++
			})

			// SHOW ME YOUR GUTS PLEASE
			var idx = (search.idx = {})

			idx.invertedIndex 			= this.invertedIndex
			idx.fieldTermFrequencies 	= this.fieldTermFrequencies
			idx.fieldLengths 			= this.fieldLengths
			idx._documents 				= this._documents
			idx.documentCount 			= this.documentCount
			idx.termIndex 				= this.termIndex
			idx.gid 					= gid
		})
		
		log("Complete!")
	}

	// Initialize lunr with pre-baked inverted index
	search.init_lunr_from_prebaked = function() {
		log("Lunr prebaked init")

		// All of the stuff should've already been set
		// Except search.idx._documents and gid
		// Manually bitbang some more stuff into existence
		search.idx._documents = {}

		var len = search.idx.documentCount

		for (var i = 0; i < len; i++) {
			var title = search.idx.id_to_filename[i]

			// Can't fetch from poneb.in...
			// Let's simply link then
			var paste_id = (title.slice(title.lastIndexOf("-") + 1)).slice(0, -4)
			var link = "https://poneb.in/" + paste_id

			var note = core.create_note(title)
			note.body = "Open at poneb.in: <a href=\""+link+"\">"+link+"</a>\n\nThe pastes here... they are too hot for GitHub.\n\nCan't fetch from poneb.in directly because `Access-Control-Allow-Origin: *` header missing.\n\nEven though you see no text, More -> \"Find similar notes\" button still functions as intended!"

			search.idx._documents[i] = {note: note}
		}

		search.idx.gid = len

		search.reinit_lunr()

		log("All OK")
	}

	// Delete a single note from the indices without regenerating them completely
	search.idx_delete_note = function(id) {
		var short_id = id.slice(2)

		// Refuse to commit operations that will ruin the index
		if (short_id in search.idx._documents === false) {
			log("No such ID")
			return
		}

		// Mark lunr for reinitialization
		delete search.lunr

		// Delete all records of the note
		var terms = search.idx.fieldTermFrequencies[id]

		for (var term in terms) {
			delete search.idx.invertedIndex[term]["a"][short_id]
		}

		delete search.idx.fieldTermFrequencies[id]
		delete search.idx.fieldLengths[id]
		delete search.idx._documents[short_id]

		search.idx.documentCount--
	}

	// Add a single note into the indices without regenerating them completely
	//
	// Depends on the following:
	// - search.idx.termIndex 				Term insertion counter; _index field of the invertedIndex entries is sampled from this counter
	search.idx_add_note = function(title) {
		// Mark lunr for reinitialization
		delete search.lunr

		var builder_fn = function () {
			this.pipeline.reset()
			this.searchPipeline.reset()

			this.pipeline.add(
				lunr.trimmer,
				lunr.stopWordFilter,
				search.partial_stemmer
			)

			this.searchPipeline.add(
				search.partial_stemmer
			)

			this.field('a')
			this.ref('id')

			this.invertedIndex 			= search.idx.invertedIndex
			this.fieldTermFrequencies 	= search.idx.fieldTermFrequencies
			this.fieldLengths 			= search.idx.fieldLengths
			this._documents 			= search.idx._documents
			this.documentCount 			= search.idx.documentCount
			this.termIndex 				= search.idx.termIndex

			var note = core.get_note_reference(title)

			this.add({id: search.idx.gid, a: note.body}, {note: note})
			search.idx.gid++

			// Backwards-sync integer variables
			search.idx.documentCount 	= this.documentCount
			search.idx.termIndex 		= this.termIndex
		}

		var builder = new lunr.Builder

		builder_fn.call(builder, builder)

		// [Optional] If you don't want to defer, lunr can be rebuilt right here:
		// search.lunr = builder.build()
	}

	// Iterate through _documents and find the specified title
	// Returns null on failure
	search.idx_find_note_id = function(title) {
		for (var id in search.idx._documents) {
			var doc = search.idx._documents[id]

			if (doc.note.title === title) return ("a/" + id)
		}

		return null
	}

	// Get note title from id
	search.idx_get_note_title = function(id) {
		return search.idx._documents[id.slice(2)].note.title
	}

	// Alert handling
	// Index will be updated in real time to reflect changes in the note storage
	search.alert = function(alert, cause) {
		// Exit if index not initialized; nothing to do, yet!
		if ("idx" in search === false) return
		
		
		// Note creation alerts are not handled because freshly created notes are still empty
		// When a note is first altered is the time to add it

		if (alert === "note_altered") {
			var id = search.idx_find_note_id(cause)

			if (id != null) {
				search.idx_delete_note(id)
			}

			search.idx_add_note(cause)
		}

		if (alert === "note_renamed") {
			// No special handling required
			// We don't store titles in the index
		}

		if (alert === "note_deleted") {
			var id = search.idx_find_note_id(cause)
			search.idx_delete_note(id)
		}
	}

	// This is a lightened version of the lunr stemmer
	// Only steps 1a and 1b remain
	// This matches what is used in the native indexer
	search.partial_stemmer = (function(){
		var c = "[^aeiou]",          // consonant
			v = "[aeiouy]",          // vowel
			C = c + "[^aeiouy]*",    // consonant sequence
			V = v + "[aeiou]*",      // vowel sequence

			mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
			meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
			mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
			s_v = "^(" + C + ")?" + v;                   // vowel in stem

		var re_mgr0 = new RegExp(mgr0);
		var re_mgr1 = new RegExp(mgr1);
		var re_meq1 = new RegExp(meq1);
		var re_s_v = new RegExp(s_v);

		var re_1a = /^(.+?)(ss|i)es$/;
		var re2_1a = /^(.+?)([^s])s$/;
		var re_1b = /^(.+?)eed$/;
		var re2_1b = /^(.+?)(ed|ing)$/;
		var re_1b_2 = /.$/;
		var re2_1b_2 = /(at|bl|iz)$/;
		var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
		var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");


		var porterStemmer = function porterStemmer(w) {
			var stem,
				suffix,
				firstch,
				re,
				re2,
				re3,
				re4;

			if (w.length < 4) { return w; }


			firstch = w.substr(0,1);
			if (firstch == "y") {
			  w = firstch.toUpperCase() + w.substr(1);
			}

			// Step 1a
			re = re_1a
			re2 = re2_1a;

			if (re.test(w)) { w = w.replace(re,"$1$2"); }
			else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }

			// Step 1b
			re = re_1b;
			re2 = re2_1b;
			if (re.test(w)) {
			  var fp = re.exec(w);
			  re = re_mgr0;
			  if (re.test(fp[1])) {
			    re = re_1b_2;
			    w = w.replace(re,"");
			  }
			} else if (re2.test(w)) {
			  var fp = re2.exec(w);
			  stem = fp[1];
			  re2 = re_s_v;
			  if (re2.test(stem)) {
			    w = stem;
			    re2 = re2_1b_2;
			    re3 = re3_1b_2;
			    re4 = re4_1b_2;
			    if (re2.test(w)) { w = w + "e"; }
			    else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
			    else if (re4.test(w)) { w = w + "e"; }
			  }
			}

			if (firstch == "y") {
			  w = firstch.toLowerCase() + w.substr(1);
			}

			return w;
		};

		return function (token) {
			return token.update(porterStemmer);
		}
	})()

	// ==============================================================================
}

</script>
<script>
"use strict";

//
// IAS cold storage
//
window.ias_cold_storage = [{
title:`minicon`,
body:`
var q_sel = note.ui.body.q_sel // Alias

var con_htmlcode =
\`
<code id="interactive_console_display" class="long glows blinker"></code>
<textarea id="interactive_console_input"></textarea>
\`

note.ui.set_body(con_htmlcode)

var display = q_sel("#interactive_console_display")
var input = q_sel("#interactive_console_input")

input.style.height = "1.2em"
input.style.width = "100%"
input.style.padding = "0px"
input.style.border = "none"
input.style.color = "white"
input.style.backgroundColor = "#333333"
input.style.overflow = "auto"
input.oninput = input_keyhit

display.style.maxHeight = "15em"
display.innerText += ">"

start_blinker(display)

function input_keyhit() {
	if (input.value.slice(-1) === "\\n") {
		var command = input.value.slice(0, -1)
		input.value = ""

		display.innerText += command + "\\n"

		try {
			display.innerText += Function("return " + command).apply() + "\\n"
		} catch(exception) {
			display.innerText += exception + "\\n"
		}
		
		display.innerText += ">"

		// Scroll to bottom
		display.scrollTo({top: display.scrollHeight, behavior: "smooth"})
	}
}

function start_blinker(console) {
	console.blinker_func = function () {
		console.classList.toggle("blinker")
	}
	
	setInterval(console.blinker_func, 250)
}`,
creation_date:1609225937327,
modification_date:1609225937327,
execute:`app`
},
{
title:`Programming guide`,
body:`IAS features two application layers:
1. API Servers
2. Userspace Apps

API Servers are stored as raw JavaScript code, and Userspace Apps are stored within notes.

# API Servers

Open your browser console and execute \`ias.core.toString()\`

This will print the entire code of the "core" API Server, the one responsible for storing and processing notes. You will notice that the code is wrapped into a function:

\`\`\`
function() {
	// ...
	// ...
	// ...

	this.API_aaa = function() { ... }
	this.API_bbb = function() { ... }
}
\`\`\`

If you are familiar with JavaScript, you will instantly recognize this as the old-school way to create custom types/classes.

A restart is required after editing the code of an API Server.

Take a look at the code of "ias.bootloader" API Server to see how the boot process unfolds.

# Userspace Apps

Userspace Apps are stored as notes, and thus to see the code of one of the apps you need to take a different approach: \`core.get_note_text("minicon")\`

This should print the string containing the code of the embedded interactive console app. It is stored as a string, so you will notice some escaped characters.

You will see that it's not wrapped into any functions/objects and is more or less written as your usual JavaScript.

Userspace Apps are executed using a Function() constructor. It provides a degree of encapsulation -- you can declare variables and functions inside, and they will not spill over into the outside world.

Here's how you start an app:

\`\`\`
var app = Function(core.get_note_text("pls_make_new_example"))
app()
\`\`\`

Try it!

Question: but can you pass arguments?
Answer: yes!

\`\`\`
var app = Function("variable_1", core.get_note_text("pls_make_new_example"))
app(123)
\`\`\`

The app will now have access to a variable \`variable_1\`, which will contain the number 123.

It is encouraged that you write your Userspace Apps in such a way that multiple copies can run in parralel.`,
creation_date:1609225934547,
modification_date:1609501864421
},
{
title:`List of all notes`,
body:`

// Perform initial update
update_list()

// Install the alert handlers
note.alerts.note_created = function() { update_list() }
note.alerts.note_altered = function() { update_list() }
note.alerts.note_renamed = function() { update_list() }
note.alerts.note_deleted = function() { update_list() }

function update_list() {
	var note_list = core.get_recent_titles(core.get_note_count())
	var html_code = ""

	for (var i = 0; i < note_list.length; i++) {
		html_code += make_link(note_list[i]) + "\\n"
	}

	note.ui.set_body(html_code)
}

function make_link(title) {
	return \`<a class="internal" href="#\${title}" onclick="story.open_note('\${title}', '\${note.info.title}'); return false;">\${title}</a>\`
}`,
creation_date:1609225934547,
modification_date:1609225934547,
execute:`app`
},
{
title:`Programming guide: alert functions`,
body:`IAS features several //alert functions// that can be used by [[Userspace Apps]]. Here's the full list:
 - note_altered				Triggered when some note was altered
 - note_renamed				Triggered when some note was renamed
 - note_deleted				Triggered when some note was deleted
 - ... 						...


Here's how an app can hook to an alert function:
\`\`\`
note.alerts.note_deleted = function(cause) { log("Time to update!") }
\`\`\`

Take a look at the \`alert_all_notes()\` of the "ias_ui" API server to see how alerts are invoked. Try searching the entire source code for calls to that function to find the places that post various alerts.`,
creation_date:1609838210065,
modification_date:1609838210065
},
{
title:`Export all notes`,
body:`
if (confirm("Download all notes as .json file?")) {
	networking.download(core.cold_storage_snapshot(), "ias_notes.json")
}`,
creation_date:1610375972182,
modification_date:1610375972182,
execute:`process`
},
{
title:`Programming guide: search`,
body:`Need to write some comments about:
1. How search initializes and reinitializes
2. Indices present
3. How live deletion/insertion unfolds
4. How apps can utilize the search
`,
creation_date:1611669194920,
modification_date:1611669194920
},
{
title:`Warning`,
body:`Very half-baked software ahead. <i>There are bugs.</i>`,
creation_date:1611675231500,
modification_date:1611675231500
},
{
title:`Search`,
body:`
if ("lunr" in search) {
	show_search_prompt()
} else {
	show_index_download_prompt()
}

function show_index_download_prompt() {
	note.ui.set_body("<p>The search needs to download one of the indexes to work.</p><p>It can take up to a minute to evaluate an index, depending on your device.</p><p>Click one of the buttons below:</p>")

	var indexes = []

	indexes.push( {title: "Index A 	53.3M 	Full Anonymous directory index.", 								url: "idx/index_a.js"} )
	indexes.push( {title: "Index B 	46.2M 	The 5 largest directories, full of non-pony crap.",	 			url: "idx/index_b.js"} )
	indexes.push( {title: "Index C 	46.1M 	Next 25 directories.",	 										url: "idx/index_c.js"} )
	indexes.push( {title: "Index D 	47.4M 	Next 45 directories.",	 										url: "idx/index_d.js"} )
	indexes.push( {title: "Index E 	49.1M 	Next 65 directories.",	 										url: "idx/index_e.js"} )
	indexes.push( {title: "Index F 	48.5M 	Next 95 directories.",	 										url: "idx/index_f.js"} )
	indexes.push( {title: "Index G 	49.9M 	Next 140 directories.",	 										url: "idx/index_g.js"} )
	indexes.push( {title: "Index H 	49.3M 	Next 195 directories.",	 										url: "idx/index_h.js"} )
	indexes.push( {title: "Index I 	49.7M 	Next 340 directories.",	 										url: "idx/index_i.js"} )
	indexes.push( {title: "Index J 	49.3M 	Next 670 directories.",	 										url: "idx/index_j.js"} )
	indexes.push( {title: "Index K 	32.0M 	Next 1826 directories.",	 									url: "idx/index_k.js"} )

	for (var i = 0; i < indexes.length; i++) {
		var index = indexes[i]

		var button = add("button", note.ui.body)
		button.innerText = index.title
		button.index_url = index.url
		button.onclick = handle_click

		add("br", note.ui.body)
	}

}

function handle_click(event) {
	download_index(event.target.index_url)
}

async function download_index(url) {
	show_status("Downloading ["+url+"]...")
	var time_dl_start_ms = performance.now()

	index_code = await networking.get(url)
	if (index_code === null) return

	show_status("Download complete; parsing the index...")
	var time_dl_done_ms = performance.now()

	var index_fn = new AsyncFunction(index_code)
	await index_fn()

	var time_idx_eval_ms = performance.now()

	success("Index installed!<br>" + (time_dl_done_ms - time_dl_start_ms) + "ms to download<br>" + (time_idx_eval_ms - time_dl_done_ms) + "ms to evaluate")

	show_search_prompt()
}

function show_search_prompt() {
	note.ui.set_body("")

	note.search_field = add("input", note.ui.body)
	note.search_field.placeholder = "Search..."
	note.search_field.type = "text"

	note.search_results_root = add("div", note.ui.body)
	note.search_results = add("div", note.search_results_root)

	note.search_results_root.style.position = "relative"
	note.search_results.style.position = "absolute"

	note.search_results.classList.add("dropdown", "hide")

	note.search_results.onmouseover = lock_results
	note.search_results.onmouseout = unlock_results
	note.search_field.onmouseover = lock_results
	note.search_field.onmouseout = unlock_results

	note.search_field.oninput = handle_input
	note.search_field.onfocus = handle_input

	document.onclick = hide_results
}

var results_locked = 0

function lock_results() { results_locked = 1 }
function unlock_results() { results_locked = 0 }

function show_results() {
	note.search_results.classList.remove("hide")
}

function hide_results() {
	if (results_locked === 0) {
		note.search_results.classList.add("hide")
	}
}

var input_timeout = 0

function handle_input() {
	clearTimeout(input_timeout)

	if (note.search_field.value === "") {
		unlock_results()
		hide_results()
	} else {
		input_timeout = setTimeout(run_search, 250)
	}
}

function run_search() {
	var query = note.search_field.value
	var unsafe_rxp_1 = /\\B\\*\\B/g // Detect stray *
	var unsafe_rxp_2 = /[~+-]$/g // Detect stray +/-/~

	var unsafe = unsafe_rxp_1.test(query) || unsafe_rxp_2.test(query)

	if (unsafe) {
		log("Refusing incomplete/unsafe query")
	} else {
		var results = search.lunr_search_text(query)
		note.search_results.innerHTML = format_results(results)
		show_results()
	} 
}

function format_results(lunr_output) {
	var html = ""
	var len = lunr_output.length

	log(lunr_output)

	if (len === 0) {
		html = "<p>Nothing found...</p>"
	} else {
		html += "<ul>"

		for (var i = 0; i < len; i++) {
			var title = lunr_output[i].title
			var tags = lunr_output[i].tags

			html += make_entry(title, tags)
		}

		html += "</ul>"
	}

	html += "<hr>Prefix words with <kbd>-</kbd> to disallow them, prefix words with <kbd>+</kbd> to make them required. Use <kbd>*</kbd> for unknown letters. Add <kbd>~1</kbd> after the word for fuzzy search with a distance of 1."

	return html
}

function make_entry(title, tags) {
	return \`<li class="search_result">\${utils.display_title(title, note.info.title)}<ul><li>\${utils.display_tags(tags)}</li></ul></li>\`
}`,
creation_date:1610984355543,
modification_date:1610984355543,
execute:`app`
}]

</script>
<script>
"use strict";

//
// IAS entry point
//
var bootloader = new ias.bootloader()
bootloader.init()
</script>
</body></html>